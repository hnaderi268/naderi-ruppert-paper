\documentclass[10pt]{article}
\renewcommand{\baselinestretch}{1.8}

\usepackage[b4paper,left=0.8in,right=0.8in,top=0.8in,bottom=0.8in]{geometry}
\usepackage{tikz-qtree}
\usepackage{algorithm}
\usepackage{algpseudocode}
\makeatletter
\renewcommand{\ALG@beginalgorithmic}{\footnotesize}
\makeatother
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{showkeys}
\usepackage{amsmath}


\usepackage{multicol}
\setlength\columnsep{24pt}

\algnewcommand\algorithmicforeach{\bf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\algdef{S}[FUNCTION]{Function}
   [3]{{\tt{\sl{#1}}} \textproc{\tt{#2}}\ifthenelse{\equal{#3}{}}{}{\tt{(#3)}}}
  
\algdef{E}[FUNCTION]{EndFunction}
   [1]{\algorithmicend\ \tt{\textproc{#1}}}

\algrenewcommand\Call[2]{\tt{\textproc{#1}\ifthenelse{\equal{#2}{}}{}{(#2)}}}
   
\newcommand\keywordfont{\sffamily\bfseries}
\algrenewcommand\algorithmicend{{\keywordfont end}}
\algrenewcommand\algorithmicfor{{\keywordfont for}}
\algrenewcommand\algorithmicforeach{{\keywordfont for each}}
\algrenewcommand\algorithmicdo{{\keywordfont do}}
\algrenewcommand\algorithmicuntil{{\keywordfont until}}
\algrenewcommand\algorithmicfunction{{\keywordfont function}}
\algrenewcommand\algorithmicif{{\keywordfont if}}
\algrenewcommand\algorithmicthen{{\keywordfont then}}
\algrenewcommand\algorithmicelse{{\keywordfont else}}
\algrenewcommand\algorithmicreturn{{\keywordfont return}}

\renewcommand\thealgorithm{}
\newcommand{\setalglineno}[1]{%
  \setcounter{ALC@line}{\numexpr#1-1}}

\newcommand{\sub}[1]{\textsubscript{#1}}
\renewcommand{\tt}[1]{\texttt{#1}}
\renewcommand{\sl}[1]{\textsl{#1}}
\renewcommand{\it}[1]{\textit{#1}}
\renewcommand{\bf}[1]{\textbf{#1}}
\newcommand{\cmt}[1]{\Comment{#1}}

\usepackage{amsmath,amssymb,amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\begin{document}

\begin{algorithm}
\caption{Fields description}
\begin{algorithmic}[1]
\setcounter{ALG@line}{100}
\begin{multicols}{2}

%\Statex \bf{Structure}

\Statex $\diamondsuit$ \tt{\sl{Shared}}
\begin{itemize}
\item \tt{\sl{Node*} tree[]} \textsf{: A binary tree of \tt{Node}s such that \tt{Tree[0]} is the root and the left child and the right child and the parent of \tt{Tree[i]} are \tt{Tree[2i+1]}, \tt{Tree[2i+2]} and \tt{Tree[i/2]}.} \label{treeRules}
\end{itemize}

\Statex

\Statex $\diamondsuit$ \tt{\sl{Local}}
\begin{itemize}
\item \tt{\sl{int} leaf\textsf{: \tt{tree[leaf]} is the process's leaf in the tree.}}
\end{itemize}

\Statex
\Statex $\diamondsuit$ \tt{\sl{Structures}}

\Statex $\blacktriangleright$ \tt{\sl{Node}}
\begin{itemize}
\item \tt{\sl{*Node} left(), right(), parent()} \textsf{: initialized  when creating the tree as mentioned in the \tt{tree[]} description \ref{treeRules}.}
\item \tt{\sl{BlockList} blocks}\textsf{: Supports two operations \tt{blocks.tryAppend(Block b), blocks[i]}. Initially  empty, when \tt{blocks.tryAppend(b)} returns true \tt{b} is appended to the end of the list and \tt{blocks[i]} returns $i$th block in the \tt{blocks}. If some instance of \tt{blocks.tryAppend(b)} returns \tt{false} there is a concurrent instance of \tt{blocks.tryAppend(b$^\prime$)} which has returned \tt{true}.\tt{blocks[0]} contains an empty block with all fields equal to 0 and \tt{end} pointers to the first block of the corresponding children.}

\item \tt{\sl{int} num\sub{propagated}= 0}\textsf{} \textsf{: \# groups of blocks have been propagated from the node. It may be behind its real value.}
\item \tt{\sl{int[]} super}\textsf{: \tt{super[i]} stores the index of the superblock of some block in \tt{blocks} that its \tt{group} field is \tt{i}.}
\end{itemize}

\Statex $\blacktriangleright$ \tt{\sl{Root} extends \sl{Node}}
\begin{itemize}
  
\item \tt{\sl{PBRT} blocks}

  \textsf{Implemented with a persistent red-black tree.}
  
\end{itemize}

\Statex $\blacktriangleright$ \tt{\sl{NonRootNode} extends \sl{Node}}
\begin{itemize}
  
\item \tt{\sl{Block[]} blocks}

  \textsf{Implemented with an array and using CAS for appending to the head.}
  
\item \tt{\sl{int} head= 1}\textsf{: \#\tt{block}s in the \tt{blocks}.}
  
\end{itemize}

\Statex $\blacktriangleright$ \tt{\sl{Leaf} extends \sl{NonRootNode}}
\begin{itemize}
  
  \item \tt{\sl{int} \tt{last\sub{done}}}

  \textsf{Each process stores the index of the most recent block in the root that the process has finished the last operation of the block. \tt{enqueue(e)} is finished if \tt{e} is returned by some \tt{dequeue()} and \tt{dequeue()} is finished when it computes its response.}
  
\end{itemize}
\pagebreak

\Statex $\blacktriangleright$ \tt{\sl{Block b}} \cmt{If \tt{b} is \tt{blocks[i](i!=0)} then \tt{b[-1] is blocks[i-1].}}

\begin{itemize}
%  \item \tt{\sl{int} num\sub{enq}, num\sub{deq}}
%  \textsf{: \# enqueue, dequeue operations in the block}
%  \item \tt{\sl{int} num, sum}
%  \textsf{: total \# operations in block, prefix sum of \tt{num}}

  \item \tt{\sl{int} group}
  \textsf{: the value read from the node \tt{n.num\sub{propagated}} when appending this block to \tt{n}.}
\end{itemize}


\Statex $\blacktriangleright$ \tt{\sl{LeafBlock} extends \sl{Block}}
\begin{itemize}
  \item \tt{\sl{Object} element}
  \textsf{: Each block in a leaf represents an operation. The \tt{element} shows the operation's argument if it is an enqueue, and if it is a dequeue this value is \tt{null}.}
  
    \item \tt{\sl{int} sum\sub{enq}, sum\sub{deq}}
  \textsf{: number of enqueue, dequeue operations in the leaf's containing this block till this block}

  
    \item \tt{\sl{Object} response}
  
  \textsf{response stores the response of the operation in the \tt{LeafBlock}.}
\end{itemize}

\Statex $\blacktriangleright$ \tt{\sl{InternalBlock} extends \sl{Block}}
\begin{itemize}
  \item \tt{\sl{int} sum\sub{enq-left}}
  \textsf{:~~\#enqueues from the subblocks in the left child + \tt{b[-1].sum\sub{enq-left}}}
  \item \tt{\sl{int} sum\sub{deq-left}}
  \textsf{:~~\#dequeues from the subblocks in the left child + \tt{b[-1].sum\sub{deq-left}}}
  \item \tt{\sl{int} sum\sub{enq-right}}
  \textsf{:~~\#enqueues from the subblocks in the right child + \tt{b[-1].sum\sub{enq-right}}}
  \item \tt{\sl{int} sum\sub{enq-right}}
  \textsf{:~~\#dequeues from the subblocks in the right child + \tt{b[-1].sum\sub{deq-right}}}
    \item \tt{\sl{int} end\sub{left}, end\sub{right}}
  \textsf{:~~index of the last subblock of the block in the left and right child}
\end{itemize}


\Statex $\blacktriangleright$ \tt{\sl{RootBlock} extends \sl{InternalBlock}}
\begin{itemize}
  \item \tt{\sl{int} size}
  \textsf{: size of the queue after this block's operations finish}
%  \item \tt{\sl{int} sum\sub{non-null deq}}
%  \textsf{: count of non-null dequeus up to this block}
  \item \tt{\sl{counter} num\sub{finished}}
  \textsf{: number of finished operations in the block}
    \item \tt{\sl{int} order}
  \textsf{: the index of the block in the node containing the block. Useful in the root since in the PBRT we do not keep indices as key.}
\end{itemize}

%\Statex $\blacktriangleright$ \tt{Conventions}
%\begin{itemize}
%  \item \tt{i} : index of ith operation in the tree
%  \item \tt{j} : index of jth operation in a node
%  \item \tt{b\sub{n}} : index of the block containing the operation n based on the scope
%  \item Also we are not going to refer to blocks directly, only with their indices. Except while constructing a new block.
%\end{itemize}


\end{multicols}
\end{algorithmic}
\end{algorithm}


\begin{footnotesize}
  
\it{Conventions}
\begin{itemize}
  \item \tt{b\sub{x}}: the block containing \tt{x}
  \item \tt{r\sub{x}}: rank of \tt{x} in the current scope
\end{itemize}

\it{Unwritten rules}
\begin{itemize}
 \item \tt{blocks[b].sum\sub{x}=blocks[b].sum\sub{x-left}+blocks[b].sum\sub{x-right}}  \tt{ (for b>0 and x $\in$ \{enq, deq\}})
 \item \tt{blocks[b].sum=blocks[b].sum\sub{enq}+blocks[b].sum\sub{deq}}  \tt{ (for b>0})
  \item \tt{blocks[b].num\sub{x}=blocks[b].sum\sub{x}-blocks[b-1].sum\sub{x}} \\ \tt{(for b>0 and x $\in$ \{$\emptyset$, enq, deq, enq-left, enq-right, deq-left, deq-right\}})
\end{itemize}
\end{footnotesize}



%##########################################


\begin{algorithm}
\caption{\tt{\sl{Queue}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{200}
\begin{multicols}{2}

\Function{void}{Enqueue}{\sl{Object} e} \cmt{Creates a block with element \tt{e} and appends it to the tree.}
\State \tt{block newBlock= \Call{new}{\sl{LeafBlock}}}
\State \tt{newBlock.element= e}
%\State \tt{b.num\sub{enq}=1}
\State \tt{newBlock.sum\sub{enq}= tree[leaf].blocks[tree[leaf].head].sum\sub{enq}+1}
\State \tt{newBlock.sum\sub{deq}= tree[leaf].blocks[tree[leaf].head].sum\sub{deq}}
\State \tt{tree[leaf].}\Call{Append}{newBlock}
\EndFunction{Enqueue}

\Statex
\Function{Object}{Dequeue()}{}
\State \tt{block newBlock= \Call{new}{\sl{LeafBlock}}} \cmt{Creates a block with null value element, appends it to the tree, computes its order among operations, then computes its response; if it exists returns the response's element.}
\State \tt{newBlock.element= null}
\State \tt{newBlock.sum\sub{enq}= tree[leaf].blocks[tree[leaf].head].sum\sub{enq}}
\State \tt{newBlock.sum\sub{deq}= tree[leaf].blocks[tree[leaf].head].sum\sub{deq}+1}
\State \tt{tree[leaf].}\Call{Append}{newBlock}
\State \tt{<r\sub{deq}, b\sub{r\sub{deq}}>=} \tt{tree[leaf].}\Call{Index\sub{Deq}}{tree[leaf].head, 1}
\Statex \cmt{\tt{r} is the rank among all dequeues of the dequeue and \tt{b\sub{r\sub{deq}}} is the index of the block in the root containing the dequeue.}
\State \tt{<r\sub{enq}, b\sub{r\sub{enq}}>=} \Call{FindResponse}{r\sub{deq}, b\sub{r\sub{deq}}} 
\Statex \cmt{\tt{r\sub{enq}} is the rank of the enqueue which is the response to the dequeue or -1 if the response is \tt{null}.} \label{deqRest}
\If{\tt{r\sub{enq}==-1}}
\State \tt{output= null}
\State \tt{tree[0].blocks[b\sub{r\sub{deq}}].num\sub{finished}.inc()} \cmt{shared counter}
\If{\tt{tree[0].blocks[b\sub{r\sub{deq}}].num\sub{finished}==tree[0].blocks[b\sub{r\sub{deq}}].num}}\cmt{all the operations in the block containing the dequeue are finished.}
\State \tt{tree[leaf].last\sub{done}= b\sub{r\sub{deq}}}
\EndIf
\pagebreak
\Else
\State \tt{output= \Call{Get\sub{enq}}{r\sub{enq}, b\sub{r\sub{enq}}}}
\State \tt{root.blocks[b\sub{r\sub{enq}}].num\sub{finished}.inc()}
\State \tt{root.blocks[b\sub{r\sub{enq}}].num\sub{finished}.inc()}
\If{\tt{root.blocks[b\sub{r}].num\sub{finished}==root.blocks[b\sub{r}].num}}
\State \tt{tree[leaf].last\sub{done}= b\sub{r\sub{enq}}}
\ElsIf {\tt{root.blocks[b\sub{r\sub{deq}}].num\sub{finished}==root.blocks[b\sub{r\sub{deq}}].num}} \cmt{\tt{root.blocks[b\sub{r}]} comes after \tt{root.blocks[b\sub{i}]}.}
\State \tt{tree[leaf].last\sub{done}= b\sub{r\sub{deq}}}
\EndIf
\EndIf
\State \Return{\tt{output}}
\EndFunction{Dequeue}


\Statex

\Function{int, int}{FindResponse}{int i, int b}\cmt{Computes the rank  and index of the block in the root of the enqueue that is the response of the \tt{i}th dequeue in the root's \tt{b}th block. Returns <-1,0> if the queue is empty.}
\If{\tt{root.blocks[b-1].size + root.blocks[b].num\sub{enq} - i $<$ 0}}
\State \Return \tt{-1, 0}
\Else
\State \tt{response= root.blocks[b-1].sum\sub{deq}- root.blocks[b-1].size + i}
\State \Return \tt{<res, tree[0].blocks.get(enq, response).order>}
\EndIf
\EndFunction{FindResponse}

\end{multicols}
\end{algorithmic}
\end{algorithm}


%##########################################


\begin{algorithm}
\caption{\tt{\sl{Node}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{300}
\begin{multicols}{2}

\Function{void}{Propagate()}{}
\If{\bf{not} \tt{this.}\Call{Refresh()}{}}
\State \tt{this.}\Call{Refresh()}{} \cmt{Lemma Double Refresh}
\EndIf
\If{\tt{this} \bf{is not} \tt{root}} \cmt{To check a node is the root we can check its index is 0.} 
\State \tt{this.parent.}\Call{Propagate()}{}
\EndIf
\EndFunction{Propagate}

\Statex

\Function{boolean}{Refresh()}{}
\State \tt{h= head}
%\If{\tt{n.blocks[h]!=null?}} \tt{h+=1}\EndIf
\State \tt{<new, np\sub{left}, np\sub{right}>= this.\Call{CreateBlock}{h}} \cmt{\tt{np\sub{left}, np\sub{right}} are the values read from the children's \tt{num\sub{propagated}}s.}
\If{\tt{new.num==0}} \Return{\tt{true}} \cmt{The block contains nothing.}
\ElsIf{\tt{root.blocks.tryAppend(new)}}
\ForEach{\tt{dir} {\keywordfont{in}} \tt{\{left, right\}}} \label{okcas}
\State \tt{\Call{CAS}{dir.super[np\sub{dir}], null, h+1}}
\State \tt{\Call{CAS}{dir.num\sub{propagated}, np\sub{dir}, np\sub{dir}+1}}
\EndFor
\State \tt{\Call{CAS}{head, h, h+1}}
\State \Return{\tt{true}}
\Else
\State \tt{\Call{CAS}{head, h, h+1}} \cmt{Even if another process wins, help to increase the head. It might fell sleep before increasing.}
\State \Return{ \tt{false}}
\EndIf
\EndFunction{Refresh}

\Statex

\Statex $\leadsto$ \textsf{Precondition: \tt{blocks[start..end]} contains a block with field \tt{f} $\geq$ \tt{i}}
\Function{int}{BSearch}{\sl{field} f, \sl{int} i, \sl{int} start, \sl{int} end}

\Statex \cmt{\textmd{Does binary search for~the value \tt{i} of the given prefix sum \tt{feild}. Returns the index of the leftmost block in \tt{blocks[start..end]} whose \sl{field} \tt{f} is $\geq$ \tt{i}}.}
%\State \Return \tt{result block's index}
\EndFunction{BSearch}

\pagebreak

\Function{<Block, int, int>}{CreateBlock}{\sl{int} i} 
\Statex\cmt{Creates a block to be inserted into \tt{this.blocks[i]}. Returns the created block as well as values read from each childnum\sub{propagated} field. The values are used for incrementing children's num\sub{propagated}s if the block was appended to \tt{this.blocks} successfully.}
\State \tt{block newBlock= \Call{new}{\sl{block}}}
\State \tt{newBlock.group= num\sub{propagated}}
\State \tt{newBlock.order= i}
\ForEach{\tt{dir} {\keywordfont{in}} \tt{\{left, right\}}}
\State \tt{index\sub{last}= dir.head} \label{lastLine}
\State \tt{index\sub{prev}= blocks[i-1].end\sub{dir}} \label{prevLine}
\State \tt{block\sub{last}= dir.blocks[index\sub{last}]}
\State \tt{block\sub{prev}= dir.blocks[index\sub{prev}]}
\State \cmt{\tt{newBlock} includes \tt{dir.blocks[index\sub{prev}+1..index\sub{last}]}.}
\State \tt{n\sub{dir}= dir.num\sub{propagated}}
\State \tt{newBlock.end\sub{dir}= index\sub{last}}
\State \tt{newBlock.sum\sub{enq-dir}= blocks[i-1].sum\sub{enq-dir} + block\sub{last}.sum\sub{enq} - block\sub{prev}.sum\sub{enq}}
\State \tt{newBlock.sum\sub{deq-dir}= blocks[i-1].sum\sub{deq-dir} + block\sub{last}.sum\sub{deq} - block\sub{prev}.sum\sub{deq}}
\EndFor
%\State \tt{b.num\sub{enq}= b.num\sub{enq-left} + b.num\sub{enq-right}}
%\State \tt{b.num\sub{deq}= b.num\sub{deq-left} + b.num\sub{deq-right}}
%\State \tt{b.num= b.num\sub{enq} + b.num\sub{deq}}
%\State \tt{b.sum= n.blocks[i-1].sum + b.num}

\If{\tt{this} \bf{is} \tt{root}}
\State \tt{newBlock.size= max(root.blocks[i-1].size + b.num\sub{enq} - b.num\sub{deq}, 0)}
%\State \tt{b.sum\sub{non-null deq}= root.blocks[i-1].sum\sub{non-null deq} + max( b.num\sub{deq} - root.blocks[i-1].size - b.num\sub{enq}, 0)}
\EndIf

\State \Return \tt{b, np\sub{left}, np\sub{right}}
\EndFunction{CreateBlock}

\end{multicols}
\end{algorithmic}
\end{algorithm}

%##########################################

\begin{algorithm}
\caption{Node}
\begin{algorithmic}[1]
\setcounter{ALG@line}{400}

\Statex $\leadsto$ \textsf{Precondition:~\tt{n.blocks[b]} contains \tt{i}th enqueue in the node.}
\Function{element}{Get\sub{Enq}}{\sl{int} b, \sl{int} i} 
\If{\tt{i $\leq$ blocks[b].num\sub{enq-left}}} \cmt{\tt{i} exists in the left child of this node}
\State \tt{subBlock= left\Call{BSearch}{sum\sub{enq}, i, blocks[b-1].end\sub{left}+1, blocks[b].end\sub{left}}}
\State \Return\tt{left.}\Call{Get}{i-left.blocks[subBlock-1].sum\sub{enq}, subBlock} 
\Else
\State \tt{i= i-blocks[b].num\sub{enq-left}}
\State\tt{subBlock= right\Call{BSearch}{sum\sub{enq}, i, blocks[b-1].end\sub{right}+1, blocks[b].end\sub{right}}}
\State \Return\tt{right.}\Call{Get}{i-right.blocks[subBlock-1].sum\sub{enq}, subBlock} 
\EndIf
\EndFunction{Get\sub{Enq}}

\Statex
\Statex $\leadsto$ \textsf{Precondition: \tt{b}th block of the node has propagated up to the root and \tt{i}th dequeue in the node is in \tt{blocks[b]}.}
\Function{<int, int>}{Index\sub{Deq}}{\sl{int} b, \sl{int} i} \cmt{Returns the order in the root of $i$th dequeue in the $b$th block of node n among dequeues.}
\State \tt{dir= (parent.left==n)? left: right} \cmt{check if a left or a right child}
\State \tt{superBlock= \Call{BSearch}{parent, sum\sub{deq-dir}, i, super[blocks[b].group]-p, super[blocks[b].group]+p}} 
\Statex\cmt{superblock's group has at most $p$ difference with the value stored in \tt{super[]}.}
\If{\tt{dir {\keywordfont is} left}}
\State \tt{i+= parent.blocks[superBlock-1].sum\sub{deq-right}}
\Else \State \tt{i+= parent.blocks[superBlock-1].sum\sub{deq} + blocks[superBlock].sum\sub{deq-left}} \cmt{consider dequeues from the right child}
\EndIf
\State \Return\Call{Index\sub{Deq}}{this.parent, superBlock, i}

\EndFunction{Index}

\end{algorithmic}
\end{algorithm}


%##########################################

\begin{algorithm}
\caption{Leaf}
\begin{algorithmic}[1]
\setcounter{ALG@line}{500}

\Function{void}{Append}{\sl{block} blk} 
\State \tt{head+=1} \label{appendEnd} \cmt{Lines \ref{appendStart} to \ref{appendEnd} are done by one process at time.}
\State \tt{blk.group= head} \label{appendStart} \cmt{Append is only called by the owener of the leaf.}
\State \tt{blocks[head]= blk} 
\State \tt{parent.}\Call{Propagate()}{} 
\EndFunction{Append}

\Statex

\Function{element}{Get\sub{Enq}}{\sl{int} b, \sl{int} i} 
\State\Return \tt{blocks[b].element}
\EndFunction{Get\sub{Enq}}

\end{algorithmic}
\end{algorithm}

%##########################################

\begin{algorithm}
\caption{Root}
\begin{algorithmic}[1]
\setcounter{ALG@line}{600}

\Function{<int, int>}{Index\sub{Deq}}{\sl{int} b, \sl{int} i} 
\State\Return \tt{<i, b>}
\EndFunction{Index\sub{Deq}}

\end{algorithmic}
\end{algorithm}

%##########################################


\begin{algorithm}
\begin{algorithmic}[1]
\setcounter{ALG@line}{700}
\begin{multicols}{2}

\Statex $\blacktriangleright$ \tt{\sl{PRBTree[rootBlock]}}
  \Statex \textsf{A persistant red-black tree supporting \tt{append(b, key),get(key=i),split(j)}}.
  \tt{append(b, key)} returns \tt{true} in case successful. Since \tt{order, sum\sub{enq}}are both strictly increasing we can use one of them for another.



\Function{void}{RBTAppend}{block b} \cmt{\textsf{adds block b to the \tt{root.blocks}}}
\State \tt{step= root.head}
\If{\tt{step\%$p^2$==0}} \cmt{Help every often $p^2$ operations appended to the root. Used in lemma's using the size of the PBRT.}
\State \tt{Help()}
\State \tt{CollectGarbage()}
\EndIf
\State \tt{b.num\sub{finished}= 0}
\State \Return \tt{root.blocks.append(b, b.order)}
\EndFunction{RBTAppend}
\Statex


\Function{void}{Help}{}\cmt{Helps pending operations}
\For{\tt{leaf l} \bf{in leaves}}\cmt{\it{if the tree is implemented with an array we can iterate over the second half of the array.}}
\State{\tt{last= l.head-1}}
\cmt{\tt{l.blocks[last]} can not be \tt{null} because of lines \ref{appendStart}-\ref{appendEnd}.}
\If{\tt{l.blocks[last].element==null}} \cmt{operation is dequeue}
\State \tt{goto \ref{deqRest} with these values <>} \cmt{run \tt{Dequeue()}  for \tt{l.ops[last]} after Propagate(). \it{TODO}}
\State \tt{l.responses[last]= response}
\EndIf
\EndFor
\EndFunction{Help}
\Statex

\Function{void}{CollectGarbage}{}\cmt{Collects the root blocks that are done.}
\State \tt{s=FindMostRecentDone(Root.Blocks.root)}  \cmt{Lemma: If block b is done after helping then all blocks before b are done as well.}
\State \tt{t1,t2= RBT.split(order, s)}
\State \tt{RBTRoot.CAS(t2.root)}
\EndFunction{CollectGarbage}

\Statex

\Function{Block}{FindMostRecentDone}{b}
\For{\tt{leaf l} \bf{in leaves}}
\State\tt{max= Max(l.maxOld, max)}
\EndFor
\State\Return\tt{max} \cmt{This snapshot suffies.}
\EndFunction{findYoungestOld}

\Statex

\Function{response}{FallBack}{op i} \cmt{\it{really necessary?}}

\If{root.blocks.get(num\sub{enq}), i is null} \cmt{this enqueue was already finished}

\State \Return \tt{this.leaf.response(block.order)}
\EndIf

\EndFunction{FallBack}

\end{multicols}
\end{algorithmic}
\end{algorithm}




\end{document}






