% !TEX root =  podc-submission.tex

\section{Future Directions}

Our focus was on optimizing step complexity for worst-case executions.
However, our queue has a higher cost than the MS-queue in the best case (when an operation
runs by itself).
Perhaps our queue could be made adaptive by having an operation capture a starting node
in the \ordering\ tree (as in \cite{DBLP:conf/stoc/AfekDT95}) rather than starting at a statically assigned leaf.
A possible application of our queue  might be to use it as the slow path in the
fast-path slow-path methodology  \cite{10.1145/2370036.2145835} to
get a queue that has good performance in practice while also having good worst-case step complexity.

There is a gap between our implementation, which takes $O(\log^2 p + \log q)$ steps per operation,
and Attiya and Fouren's $\Omega(\min(c,\log\log p))$ lower bound \cite{DBLP:conf/opodis/AttiyaF17}.
It would be interesting to determine how the true step complexity of lock-free queues (or, more generally, bags)
depends on $p$.
Since a queue is also a bag, it is the first lock-free bag we know of that has polylogarithmic step complexity.

We believe the approach used here to implement a lock-free queue 
could be applied to obtain other lock-free
data structures with a polylogarithmic step complexity.
For example, we can easily adapt our routines to implement a  vector data structure that stores a sequence and
provides three operations: \opa{Append}{e} to add an element \var{e} to the end of the sequence,
\opa{Get}{i} to read the \var{i}th element in the sequence, and
\opa{Index}{e} to compute the position of element \var{e} in the sequence.
%\here{Can omit rest of this paragraph to save space}
%An \opa{append}{e} is implemented like \opa{Enqueue}{e} in $O(\log p)$ steps.  
%A \opa{get}{i} is similar to \op{GetEnqueue}, taking $O(\log n + \log^2p)$ steps when the vector has $n$ elements.  
%An \opa{index}{e} is similar to \op{IndexDequeue} (except operating on enqueues instead of dequeues) and would take $O(\log p)$ steps.
\here{doublecheck all preceding claims for accuracy.}
We would like to investigate whether a similar approach could be used for stacks, deques or even priority queues.

