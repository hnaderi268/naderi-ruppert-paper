%%
%% This is file generated with the docstrip utility from the source file: 
%%
%% samples.dtx  (with options: `acmsmall-conf')
%% With some modifications for PODC 2023.
%% For the copyright see the source file.
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[acmsmall,nonacm,anonymous]{acmart}

\usepackage{tikz-qtree}
\usepackage{algorithm}
\usepackage{algpseudocode}
\makeatletter
\renewcommand{\ALG@beginalgorithmic}{\footnotesize}
\makeatother
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{relsize}
\usepackage{enumitem}
\usepackage{bold-extra}
\usepackage{showkeys}
\renewcommand*\contentsname{Table of Contents}

\usepackage{multicol}
\setlength\columnsep{24pt}

\def\draft{0}  % set to 1 for draft (include comments, color edits), 0 for clean final copy (omit comments, edits in black)
\if\draft 1
\newcommand{\mycomment}[3]{{\color{#2}{[\bf{#1: #3}]}}}
\newcommand{\myedit}[2]{{\color{#1}{#2}}\normalcolor}
\newcommand{\rebuttaledit}[2]{{\color{#1}{#2}}\normalcolor}
\newcommand{\here}[1]{\bf{[[[#1]]]}}
%\usepackage{showkeys}
\else
\newcommand{\mycomment}[3]{}
\newcommand{\rebuttaledit}[2]{#2}
\newcommand{\myedit}[2]{#2}
\newcommand{\here}[1]{}  % \here's include comments to ourselves that readers should not see.
\fi

\newcommand{\Eric}[1]{\mycomment{Eric}{magenta}{#1}}
\newcommand{\Hossein}[1]{\mycomment{Hossein}{blue}{#1}}
\newcommand{\er}[1]{\myedit{magenta}{#1}}

\algnewcommand\algorithmicforeach{\bf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\algdef{S}[FUNCTION]{Function}
   [3]{{\tt{\sl{#1}}} {\tt{#2}}\ifthenelse{\equal{#3}{}}{}{\tt{(#3)}}}
  
\algdef{E}[FUNCTION]{EndFunction}
   [1]{\algorithmicend\ \tt{{#1}}}

\algrenewcommand\Call[2]{\tt{{#1}\ifthenelse{\equal{#2}{}}{}{(#2)}}}
\usepackage{eqparbox}
\renewcommand{\algorithmiccomment}[1]{\hfill\eqparbox{COMMENT}{\com\ #1}}

\newcommand\keywordfont{\sffamily\bfseries}
\algrenewcommand\algorithmicend{{\keywordfont end}}
\algrenewcommand\algorithmicfor{{\keywordfont for}}
\algrenewcommand\algorithmicforeach{{\keywordfont for each}}
\algrenewcommand\algorithmicdo{{\keywordfont do}}
\algrenewcommand\algorithmicuntil{{\keywordfont until}}
\algrenewcommand\algorithmicfunction{{\keywordfont function}}
\algrenewcommand\algorithmicif{{\keywordfont if}}
\algrenewcommand\algorithmicthen{{\keywordfont then}}
\algrenewcommand\algorithmicelse{{\keywordfont else}}
\algrenewcommand\algorithmicreturn{{\keywordfont return}}

\newcommand{\eleft}{\var{end\sub{left}}}
\newcommand{\eright}{\var{end\sub{right}}}
\newcommand{\edir}{\var{end\sub{dir}}}


\renewcommand\thealgorithm{}
\newcommand{\setalglineno}[1]{%
  \setcounter{ALC@line}{\numexpr#1-1}}

\newcommand{\sub}[1]{\textsubscript{#1}}
\renewcommand{\tt}[1]{\texttt{#1}}
\renewcommand{\sl}[1]{\textsl{#1}}
\renewcommand{\it}[1]{\textit{#1}}
\renewcommand{\sc}[1]{\textsc{#1}}
\renewcommand{\bf}[1]{\textbf{#1}}
\newcommand{\nf}[1]{{\normalfont{\texttt{#1}}}}
\newcommand{\cmt}[1]{\Comment{#1}}
\newcommand{\head}{head}
\newcommand{\size}{size }

\newcommand{\ceil}[1]{\lceil #1 \rceil}
\newcommand{\nil}{nil}
\newcommand{\opa}[2]{\nf{#1(#2)}}
\newcommand{\op}[1]{\nf{#1}}
\newcommand{\var}[1]{\nf{#1}}
\newcommand{\com}{$\triangleright$}

\usepackage{amsmath,amsthm}
%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{observation}{Observation}
%\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
\newtheorem{invariant}{Invariant}
%\newtheorem{proposition}[theorem]{Proposition}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{none}  %FIX FOR CAMERA READY
%\copyrightyear{2023}
%\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}
\fancyfoot{} % REMOVE THIS LINE FOR CAMERA READY

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[PODC 2023]{ACM Symposium on Principles of Distributed Computing}{June 19--23,
  2023}{Orlando, FL}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

\title{A Wait-free Queue with Polylogarithmic Step Complexity}


%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Eric Ruppert}
\affiliation{%
  \institution{York University}
  \streetaddress{P.O. Box 1212}
  \city{Toronto}
  \state{Ontario}
  \country{Canada}
  \postcode{43017-6221}
}
\email{ruppert@cse.yorku.ca}
\orcid{1234-5678-9012}

\author{Hossein Naderibeni}
\email{hnaderi268@gmail.com}
\affiliation{%
  \institution{York University}
  \streetaddress{P.O. Box 1212}
  \city{Toronto}
  \state{Ontario}
  \country{Canada}
  \postcode{43017-6221}
}

\settopmatter{printacmref=false}  % REMOVE THIS LINE FOR CAMERA READY

\begin{abstract}
We introduce a novel linearizable wait-free queue implementation using single-word 
CAS instructions.
Previous lock-free queues all take $\Omega(p)$ steps per operation in the worst case, 
where $p$ is the number of processes that can access the queue.
We achieve $O(\log^2 p +\log q)$ steps per operation, where $q$ is the size of the queue.
\here{mention space usage; update time bound if space-efficient version takes more time per op}
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{concurrent data structures, wait-free queues}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\input{introduction}
\input{related}
\input{algorithm}


\subsection{Pseudocode} \label{algQ}
We present our algorithm in pseudocode. page~22 contains the description of the fields in the tree nodes and the blocks. The value of any uninitialized field is \nf{null}. page~23 contains major routines and the rest of this section consists of the auxiliary routines. The abbreviations below are used in the pseudocode and the proof of correctness.
\begin{itemize}
 \item \tt{blocks[$b$].sum\sub{x}=blocks[$b$].sum\sub{x-left}+blocks[$b$].sum\sub{x-right}} (for internal blocks where $b\geq 0$ and \tt{x} $\in$ \tt{\{enq, deq\}})
%  \item \tt{blocks[b].sum=blocks[b].sum\sub{enq}+blocks[b].sum\sub{deq}}  \tt{ (for b$\geq$0})
  \item \tt{blocks[$b$].num\sub{x}=blocks[$b$].sum\sub{x}-blocks[$b-1$].sum\sub{x}}  (for all blocks where $b>0$ and \tt{x} $\in$ \tt{\{enq, deq, enq-left, enq-right, deq-left, deq-right\}})
\end{itemize}




\begin{algorithm}
\caption{\tt{\sl{Queue}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{0}


\Function{void}{Enqueue}{\sl{Object} e} \cmt{Creates a \tt{block} with element \tt{e} and adds it to the tree.}
\State \tt{block newBlock= \Call{new}{\sl{LeafBlock}}}
\State \tt{newBlock.element= e}
\State \tt{newBlock.sum\sub{enq}= leaf.blocks[leaf.\head].sum\sub{enq}+1}
\State \tt{newBlock.sum\sub{deq}= leaf.blocks[leaf.\head].sum\sub{deq}}
\State \tt{leaf.}\Call{Append}{newBlock}
\EndFunction{Enqueue}

\Statex

\Statex \com\ Creates a block with \nf{null} value element, appends it to the tree and returns its response.
\Function{Object}{Dequeue()}{} 
\State \tt{block newBlock= \Call{new}{\sl{LeafBlock}}} 
\State \tt{newBlock.element= null}
\State \tt{newBlock.sum\sub{enq}= leaf.blocks[leaf.\head].sum\sub{enq}}
\State \tt{newBlock.sum\sub{deq}= leaf.blocks[leaf.\head].sum\sub{deq}+1}
\State \tt{leaf.}\Call{Append}{newBlock}
\State \tt{<b, i>=} \Call{IndexDequeue}{leaf.\head, 1}
\State \tt{output=} \Call{FindResponse}{b, i} 
\label{deqRest}
\State \Return{\tt{output}}
\EndFunction{Dequeue}

\Statex

\Statex \com\ Returns the response to $D_i(root,b)$, the \nf{i}th \nf{Dequeue} in \nf{root.blocks[b]}.
\Function{element}{FindResponse}{\sl{int} b, \sl{int} i}
\If{\tt{ root.blocks[b-1].\size}\tt{ + root.blocks[b].num\sub{enq} - i $<$ 0}} \label{checkEmpty}\cmt{Check if the queue is empty.}
\State \Return \tt{null} \label{returnNull}
\Else \cmt{The response is $E_e(root)$, the \nf{e}th \nf{Enqueue} in the root.}
\State \tt{e= i + (root.blocks[b-1].sum\sub{enq}-root.blocks[b-1].size)} \label{computeE}
\State \Return \tt{root.GetEnqueue(root.\Call{DoublingSearch}{e, b})}\label{findAnswer}
\EndIf
\EndFunction{FindResponse}

\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\caption{\tt{\sl{Node}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{25}

\Statex $\leadsto$ \textsf{Precondition: \tt{blocks[start..end]} contains a block with \tt{sum\sub{enq}} greater than or equal to \tt{x}}
\Statex \com\ \textmd{Does a binary search for~the value \tt{x} of \tt{sum\sub{enq}} field and returns the index of the leftmost block in\\
\com\ \tt{blocks[start..end]} whose \tt{sum\sub{enq}} is $\geq$ \tt{x}}.
\Function{int}{BinarySearch}{\sl{int} x, \sl{int} start, \sl{int} end}
% \State \Return \tt{min\{j: blocks[j].sum\sub{enq}$\geq$x\}}
\While{\nf{start<end}}
\State \tt{\sl{int}} \tt{mid= floor((start+end)/2)}
\If{\nf{blocks[mid].sum\sub{enq}<x}}
\State \nf{start= mid+1}
\Else
\State \nf{end= mid}
\EndIf
\EndWhile
\State\Return \nf{start}
\EndFunction{BinarySearch}

\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{\tt{\sl{Root}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{36}
\Statex
\Statex $\leadsto$ \textsf{Precondition: \tt{root.blocks[end].sum\sub{enq} $\geq$ \tt{e}}}
\Statex \com\ \textmd{Returns \tt{<b,i>} such that $E_\nf{e}(\nf{root})=E_\nf{i}(\nf{root},\nf{b})$, i.e., the \nf{e}th \nf{Enqueue} in the \nf{root} is the \nf{i}th \nf{Enqueue} within \\
\com\ the \nf{b}th block in the \nf{root}.}

\Function{<int, int>}{DoublingSearch}{\sl{int} e, \sl{int} end}
\State \tt{start= end-1} \label{dsearchStart}
\While{\tt{root.blocks[start].sum\sub{enq}}$>=$\tt{e}}
\State \tt{start= max(start-(end-start), 0)} \label{doubling}
\EndWhile \label{dsearchEnd}
\State \tt{b= root.BinarySearch(e, start, end)} \label{dsearchBinarySearch}
\State \tt{i= e- root.blocks[b-1].sum\sub{enq}} \label{DSearchComputei}
\State\Return \tt{<b,i>}
\EndFunction{DoublingSearch}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{\tt{\sl{Leaf}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{45}

\Function{void}{Append}{\sl{block} B} \cmt{Only called by the owner of the leaf.}
\State \tt{blocks[\head]= B} \label{appendLeaf}
\State \tt{\head= \head+1} \label{appendEnd} 
\State \tt{parent.}\Call{Propagate()}{} 
\EndFunction{Append}

\end{algorithmic}
\end{algorithm}




\begin{algorithm}
\caption{\tt{\sl{Node}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{50}


\Statex \com\ \textmd{\nf{$n$.Propagate} propagates operations  in \nf{this}.children up to \nf{this} when it terminates.}
\Function{void}{Propagate()}{}
\If{\bf{not} \Call{Refresh()}{}} \label{firstRefresh}
\State \Call{Refresh()}{} \label{secondRefresh}
\EndIf
\If{\tt{this} \bf{is not} \tt{root}}
\State \tt{parent.}\Call{Propagate()}{}
\EndIf
\EndFunction{Propagate}

\Statex

\Statex \com\ \textmd{Creates a block containing new operations of \nf{this.}children, and then tries to append it to \nf{this}.}
\Function{boolean}{Refresh()}{}
\State \tt{h= \head} \label{readHead}
\ForEach{\tt{dir} {\keywordfont{in}} \tt{\{left, right\}}} \label{startHelpChild1}
\State \tt{h\sub{dir}= dir.\head} \label{readChildHead}
\If{\nf{dir.blocks[h\sub{dir}]!=null}} \label{ifHeadnotNull}
\State{\tt{dir.\Call{Advance}{h\sub{dir}}}} \label{helpAdvance}
\EndIf
\EndFor \label{endHelpChild1}
\State \tt{new= \Call{CreateBlock}{h}} \label{invokeCreateBlock}
\If{\tt{new.num==0}} \Return{\tt{true}} \label{addOP} 
\EndIf
\State{\tt{result= blocks[h].CAS(null, new)}} \label{cas}
\State{\tt{this.\Call{Advance}{h}}} \label{advance}
\State \Return{ \tt{result}}

\EndFunction{Refresh}


\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{\tt{\sl{Node}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{73}

\Function{void}{Advance}{\sl{int} h} \cmt{Sets \nf{blocks[h].super} and increments \nf{head} from \nf{h} to \nf{h+1}.}
\State \tt{h\sub{p}= parent.\head} \label{readParentHead}
\State \tt{blocks[h].super.CAS(null, h\sub{p})} \label{setSuper1}
\State \tt{head.CAS(h, h+1)} \label{incrementHead}
\EndFunction{Advance}

\Statex

\Function{Block}{CreateBlock}{\sl{int} i} \cmt{Creates and returns the block to be installed in \tt{blocks[i]}.}
\State \tt{block new= \Call{new}{\sl{InternalBlock}}} \label{initNewBlock}
\ForEach{\tt{dir} {\keywordfont{in}} \tt{\{left, right\}}}
\State \tt{index\sub{prev}= blocks[i-1].\edir} \label{prevLine}
\State \tt{new.\edir= dir.\head-1} \label{lastLine} \cmt{\nf{new} contains \tt{dir.blocks[blocks[i-1].\edir..dir.\head-1]}.}
\State \tt{block\sub{prev}= dir.blocks[index\sub{prev}]}
\State \tt{block\sub{last}= dir.blocks[new.\edir]}
\State \tt{new.sum\sub{enq-dir}= blocks[i-1].sum\sub{enq-dir} + block\sub{last}.sum\sub{enq} - block\sub{prev}.sum\sub{enq}} \label{setSumEnqLeft}
\State \tt{new.sum\sub{deq-dir}= blocks[i-1].sum\sub{deq-dir} + block\sub{last}.sum\sub{deq} - block\sub{prev}.sum\sub{deq}} \label{setSumEnqRight}
\EndFor
\If{\tt{this} \bf{is} \tt{root}}
\State \tt{new.type= \sl{InternalBlock}-->\sl{RootBlock}}
\State \tt{new.size= max(root.blocks[i-1].\size { }+ new.num\sub{enq}- new.num\sub{deq}, 0)}\label{computeLength}
\EndIf

\State \Return \tt{new}
\EndFunction{CreateBlock}


\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\caption{\tt{\sl{Node}}}
\begin{algorithmic}[1]
\setcounter{ALG@line}{94}

\Statex $\leadsto$ \textsf{Precondition:~\tt{blocks[b].num\sub{enq}$\geq$i$\geq 1$}}
\Function{element}{GetEnqueue}{\sl{int} b, \sl{int} i} \cmt{Returns the \tt{element} of $E_\tt{i}(\tt{this},\tt{b})$.}
\If{\tt{this} \bf{is} \tt{leaf}}
\State\Return \tt{blocks[b].element} \label{getBaseCase}
\ElsIf{\tt{i <= blocks[b].num\sub{enq-left}}} \label{leftOrRight} \cmt{$E_\tt{i}(\tt{this},\tt{b})$ is in the left child of this node.}
\State \tt{subblockIndex= left.BinarySearch(i+blocks[b-1].sum\sub{enq-left}, blocks[b-1].\eleft+1,} \label{leftChildGet}
\Statex \hspace{10.7em}\tt{blocks[b].\eleft)} 
\State \Return\tt{left.}\Call{GetEnqueue}{subblockIndex, i} 
\Else
\State \tt{i= i-blocks[b].num\sub{enq-left}}
\State\tt{subblockIndex= right.BinarySearch(i+blocks[b-1].sum\sub{enq-right}, blocks[b-1].\eright+1,} \label{rightChildGet}
\Statex \hspace{11.1em}\tt{blocks[b].\eright)} 
\State \Return\tt{right.}\Call{GetEnqueue}{subblockIndex, i} 
\EndIf
\EndFunction{GetEnqueue}

\Statex
\Statex $\leadsto$ \textsf{Precondition: \tt{b}th block of the node has propagated up to the root and \tt{blocks[b].num\sub{deq}$\geq$i}.}
\Function{<int, int>}{IndexDequeue}{\sl{int} b, \sl{int} i} \cmt{Returns \tt{<x, y>} if $D_\tt{i}(\tt{this}, \tt{b})=D_\tt{y}(\tt{root},\tt{x})$.}
\If{\tt{this} \bf{is} \tt{root}}
\State\Return \tt{<b, i>} \label{indexBaseCase}
\Else
\State \tt{dir= (parent.left==n ? left: right)} 
\State \tt{superblockIndex= parent.blocks[blocks[b].super].sum\sub{deq-dir} > blocks[b].sum\sub{deq} ? \label{computeSuper}
\Statex \hspace{11.3em} blocks[b].super: blocks[b].super+1}

\If{\tt{dir {\keywordfont is} left}} \label{computeISuperStart}
\State \tt{i+= blocks[b-1].sum\sub{deq}-parent.blocks[superblockIndex-1].sum\sub{deq-left}} \label{considerPreviousLeft}
\Else \label{considerRight}
\State \tt{i+= blocks[b-1].sum\sub{deq}-parent.blocks[superblockIndex-1].sum\sub{deq-right}}  \label{considerPreviousRight}
\State \tt{i+= parent.blocks[superblockIndex].num\sub{deq-left}}  \label{considerLeftBeforeRight}
\EndIf \label{computeISuperEnd}
\State \Return\tt{this.parent.}\Call{IndexDequeue}{superblockIndex, i}
\EndIf
\EndFunction{IndexDequeue}

\end{algorithmic}
\end{algorithm}

\input{correctness}

\input{analysis}

\input{boundedspace}

\input{conclusion}

\newpage

\bibliographystyle{plain}
\bibliography{queues.bib}

\appendix
\end{document}
