% !TEX root =  podc-submission.tex

\section{Queue Implementation} \label{DescriptQ}

\subsection{Overview}
We use a \emph{tournament tree} to agree on a total ordering of the operations performed on the queue.
The tree is a static binary tree of height $\ceil{\log_2 p}$ with one leaf 
assigned to each process. 
Each tree node  stores an array of \emph{blocks}, where each block represents a 
sequence of enqueues and a sequence of dequeues.
See Figure \ref{tournament} for an example.
In this section, we assume for simplicity that each node has an infinite blocks array.
Section \ref{reducing} describes how to replace the infinite array by a representation that uses bounded space.


To perform an operation on the queue, a process $P$ creates a block containing that single 
operation and appends it to the blocks array in $P$'s leaf.
Then, $P$ attempts to propagate the operation to each node along the path from that leaf to the root of the tree.
We shall define a total order on all operations that have been propagated to the root, which 
will serve as the linearization ordering of the operations.

To propagate an operation to a node $v$ in the tree, $P$ first observes
the blocks in both of $v$'s children that are not already in $v$,
creates a new block by combining information from those blocks, and attempts to append this 
new block to $v$'s blocks array using a CAS instruction.
Following \cite{}, we call this a 3-step sequence a
\op{refresh} on $v$. %(see Figure \ref{fig::propagstep}).
A successful \op{refresh} by $P$ may propagate pending operations by several other processes to $v$.
This cooperative approach is sufficient to ensure that if $P$ fails to CAS a 
new block into $v$'s array twice,
then its operation has been propagated to $v$ by some other process, so $P$ can continue 
onwards towards the root.

Now suppose $P$'s operation has been propagated all the way to the root.
If $P$'s operation is an enqueue, it has obtained a place in the linearization ordering and can terminate.
If $P$'s operation is a dequeue, $P$ must use information in the tree to compute the value that the
dequeue must return.  To do this, $P$ first determines which block in the root contains its operation
(since the operation may have been propagated to the root by some other process).
Then, $P$ determines whether the queue is empty when its dequeue is linearized. 
If so, it returns \nl\ and we call it a \emph{null dequeue}.
If not, $P$ computes the rank\footnote{We say that the $r$th element in a sequence has rank $r$ within that sequence.} $r$ of its dequeue in the linearization ordering
among all non-null dequeues,
finds the $r$th enqueue in the linearization, and returns that enqueue's value.

The primary challenge is thus figuring out what information to store in each block so that 
the following tasks can be done efficiently (in a polylogarithmic number of steps).
\begin{enumerate}[label={(T\arabic*)}]
\item
\label{construct}
Construct a block for node $v$ that represents the operations contained in $O(p)$ consecutive blocks in $v$'s children, as required for a \op{refresh}.
\item
\label{findinroot}
Given a dequeue in a leaf that has been propagated to the root, find that operation's position in the root's blocks array.
\item
\label{findrank}
Given a dequeue's position in the root, determine whether it is a null dequeue (i.e., whether the queue is empty when it is linearized)
or determine the rank $r$ of the enqueue whose value it should return.
\item
\label{findenqueue}
Find the $r$th enqueue in the linearization ordering.
\end{enumerate}
Since these tasks depends on the linearization ordering, we describe that ordering next.

\begin{figure}[tb]
\input{tournamentTree.pdf_t}
\caption{An example tournament tree with four processes. 
We show explicitly the enqueue sequence and dequeue sequence represented by each block in the \fld{blocks} arrays of the seven nodes.  The leftmost element of each \fld{blocks} array is a dummy block.
Arrows represent the indices stored in \eleft\ and \eright\ fields of blocks (as described in Section \ref{sec:fields}).
The fourth process's Deq\sub{6} is still in progress.
The linearization order for this tree is
Enq(a) Enq(e) Deq\sub{2} $\mid$ Enq(b) Deq\sub{4} Deq\sub{5} $\mid$ Enq(d) Enq(f) Enq(h) Deq\sub{1} $\mid$ Enq(c) Deq\sub{3} $\mid$ Enq(g), where vertical bars indicate boundaries of blocks in the root.\label{tournament}}
\end{figure}

\begin{figure}
\input{implicit.pdf_t}
\caption{\label{implicit}The actual, implicit representation of the tree shown in Figure \ref{tournament}.
The leaf blocks simply show the \fld{element} field.
Internal blocks show the \fld{sum\sub{enq}} and \fld{sum\sub{deq}} fields,
and \eleft\ and \eright\ fields are shown using arrows as before.
Root blocks also contain the additional \fld{size} field.
The \fld{super} field is not shown.}
\end{figure}

\subsection{Linearization Ordering}

An operation can terminate only after a block containing it has been appended to the root's blocks array.
So, if an operation $op_1$ terminates before another operation $op_2$ begins, 
$op_1$ will be in an earlier block than $op_2$ in root's blocks array.
Thus, our linearization orders operations according to the block they belong to in the root's blocks array.
Operations that appear in the same block are necessarily concurrent, so we can choose how to order them.

Each block in a leaf represents a single operation.
Each block $B$ in an internal node $v$ results from merging
several consecutive blocks from each of $v$'s children.
The blocks in $v$'s children are called the \emph{direct subblocks} of $B$.
A block $B'$ in a descendant of $v$ is a \emph{subblock} of $B$ if it is a direct subblock of $B$
or a subblock of a direct subblock of $B$.
A block $B$ represents the set of operations in all of $B$'s subblocks in leaves of the tree.

The operations propagated by a \op{refresh} are all pending when the \op{refresh} occurs,
so there is at most one operation per process.
Hence, a block represents at most $p$ operations in total.  
Moreover, we never append empty blocks, so 
each block represents at least one operation and it follows that a block can have at most $p$ direct subblocks.

As mentioned above, we are free to order operations within a block however we like.
For convenience, we order the enqueues and dequeues separately, and put the 
operations that were propagated from the left child before the operations from the right child.
More formally, we inductively define an sequence $E(B)$ of the enqueues represented by a block $B$.
If $B$ is a block in a leaf representing an enqueue operation, its enqueue sequence $E(B)$ is either the single
enqueue represented by the block (if $B$ stores an enqueue), or the empty sequence (if $B$ stores a dequeue).
If $B$ is a block in an internal node $v$ with direct subblocks $B^L_1, \ldots, B^L_\ell$ from the left child of $v$
and $B^R_1,\ldots,B^R_r$ from the right child of $v$, then $B$'s enqueue sequence is the concatenation $E(B^L_1)\cdots E(B^L_\ell)\cdot E(B^R_1) \cdots E(B^R_r)$.
The dequeue sequence $D(B)$ of a block $B$ is defined symmetrically.

Finally, when designing a total order for the operations propagated to the root, we choose
to put each block's enqueues before its dequeues.
Thus, if the root's blocks array contains blocks $B_1, \ldots, B_k$, the 
linearization ordering is 
$E(B_1)\cdot D(B_1) \cdot E(B_2) \cdot D(B_2) \cdots E(B_k) \cdot D(B_k)$.



\subsection{Designing a Block Representation to Solve Tasks \ref{construct} to \ref{findenqueue}}
\label{sec:fields}

Each \node\ of the tournament tree has an infinite array called \fld{blocks}.
To simplify the code, each \node\ has an empty \block\ in \fld{blocks[0]}.
Each \node\ also has a \fld{head} index that stores the position in the \fld{blocks} array to be used
for the next attempt to append a \block\ to this \node.

If a block contained an explicit representation of its sequences of enqueues and dequeues,
it would take $\Omega(p)$ time to construct a block, which would be too slow for task \ref{construct}.
Instead, the block stores an implicit representation of the sequences.
We now explain how we designed the fields for this implicit representation. 
Refer to Figure \ref{implicit} for an example showing how the tree in Figure \ref{tournament} is actually represented, and Figure \ref{object-fields} for the definitions of the fields of \blocks\ and \nodes.

The information stored in a \block\ depends on whether it is in an internal node or a leaf.
A block in a leaf represents a single enqueue or dequeue.  The \fld{element} field stores the value
enqueued for an enqueue operation, or \nl\ if the operation is a dequeue.

\here{If space permits, we might want to add some examples in the following paragraphs that refer back to Figure \ref{implicit}.}

Each block in an internal \node\ $v$ stores the indices of the last direct subblock in $v$'s left and right child in the fields \eleft\ and \eright.  This allows us to navigate to the direct subblocks of any block easily.
Blocks also store prefix sums of the numbers of enqueues and dequeues:
the block in $v.\fld{blocks}[i]$ has two fields \fld{sum\sub{enq}} and \fld{sum\sub{deq}}
that store the total number of enqueues and dequeues in $\var{v}.\fld{blocks}[1..\var{i}]$.
These fields allow us to pinpoint the exact location of an operation among the subblocks of a given block.
For example, consider finding the $r$th enqueue in the linearization ordering.
We use the \fld{sum\sub{enq}} fields of the root's blocks to do a binary search
to locate which block in the root contains the operation.
If we know which block $B$ in some \node\ $v$ contains the enqueue,
we can use the \fld{sum\sub{enq}} field again to determine which child of $v$ contains the enqueue
and then to do a binary search
among the direct subblocks of $B$ in that child.
Thus, we work our way down the tree until we find a leaf block, which explicitly stores 
the enqueue.
%Now, suppose we want to find the $r$th enqueue in the linearization ordering for task \ref{findenqueue}.Let $B_1, B_2, \ldots, B_k$ be the blocks in the root.
%First, we need prefix sums of the number of enqueues in $E(B_1)\cdot E(B_2)\cdots E(B_i)$
%so that we can do a binary search for the block $B_e$ that contains the $r$th enqueue.
%This prefix sum also allows us to know the rank $r'$ within $E(B_e)$ of the $r$th enqueue.
%Once we have $r'$, we need the number of enqueues that $B_e$ received from its left child
%to determine whether the enqueue came from the left or right child of the root.
%Suppose the enqueue came from the right child $v_r$.
%Then, we know that the index of the block in $v_r$ that contains the enqueue
%is between $B_{e-1}.\eright + 1$ and $B_e$.\eright.
%We can again do a binary search within this range.
%For this, we can again use the prefix sums of the number of enqueues in any prefix of the array $v_r.blocks$.
%We can then continue in this way down the tree until reaching a leaf where the enqueue is stored explicitly.
We shall show that the binary search in the root can be done in $O(\log p + \log q)$ steps,
and the binary search within each other \node\ along the path to a leaf can be done in $O(\log p)$ steps,
for a total of $O(\log^2 p + \log q)$ steps to complete task \ref{findenqueue}.
All of the information needed for this search process can be derived from the 
\eleft, \eright\ and \fld{sum\sub{enq}} fields.

To facilitate task \ref{findinroot}, each block has a field \fld{super} that contains
the (approximate) index of its superblock in the parent \node's \fld{blocks} array.
We will ensure that this field's value differs from the true index of the superblock by at most 1.
This allows a process to determine the true location of the superblock by checking the \eleft\ or \eright\ values of just two \blocks\ in the parent \node.
Thus, starting from an operation in a leaf's block, one can use these indices to track the 
operation all the way up the path to the root, and determine the operation's location in a root block
in $O(\log p)$ time.

We now consider task \ref{findrank}.
First, we must determine whether the queue is empty when a dequeue occurs.
To facilitate this, each block in the root stores a \fld{size} field that stores the number of elements
in the queue after all operations in the linearization ordering up to that block (inclusive) 
have been performed.
We can easily determine which dequeues in a block $B_d$ in the root are null dequeues using
$B_{d-1}.\fld{size}$, which stores the size of the queue just before $B_d$'s operations are performed, and the number of enqueues and dequeues in $B_d$.
We can also compute the number of non-null dequeues in blocks $B_1, \ldots, B_{d-1}$ 
as $B_{d-1}.\fld{sum\sub{enq}}-B_{d-1}.\fld{size}$.
Then, for any non-null dequeue in $B_d$, we can use this information to determine its
rank among all non-null dequeues in the linearization ordering, and hence the rank of the enqueue
whose value it should return (among all enqueues).

Now that we have defined the fields required for tasks \ref{findinroot}, \ref{findrank} and \ref{findenqueue},
we can easily see how to construct a new block $B$ during a \op{refresh} in $O(1)$ time.
A \op{refresh} on \node\ $v$ reads the value $h$ of the \fld{head} field of each of $v$'s children and stores 
$h-1$ in the $B.\eleft$ and $B.\eright$ fields of the new block.
Then, we can compute $B.\fld{sum\sub{enq}}$ as $v.\fld{left}.\fld{blocks}[B.\eleft].\fld{sum\sub{enq}} + v.\fld{right}.\fld{blocks}[B.\eright].\fld{sum\sub{enq}}$.
For a block $B$ in the root, $B.\fld{size}$ can be computed using the \fld{size} field of the previous block $B'$ and
the number of enqueues and dequeues in $B$:
$B.\fld{size} = \max(0, B'.\fld{size} + (B.\fld{sum\sub{enq}}-B'.\fld{sum\sub{enq}}) - (B.\fld{sum\sub{deq}} - B'.\fld{sum\sub{deq}}))$.

The only remaining field is $B.\fld{super}$.  When the block 
$B$ is created for a \node\ $v$, we do not yet know where its
superblock will eventually be installed in $B$'s parent.
So, we leave this field blank.  After $B$ is installed 
in $v.\fld{blocks}[\var{i}]$, processes cooperate to fill it in 
when they attempt to advance $v.\fld{head}$ from $i$ to $i+1$.
They use the value read from the \fld{head} field of $v$'s parent at that time.
As mentioned above, this might not be exactly the right index for $B$'s superblock, but we
shall prove that it is close.

\renewcommand{\algorithmiccomment}[1]{\hfill\eqparbox{COMMENTSINGLE}{\com\ #1}}
\begin{figure}
\here{Does \var{leaf} have to be shared for helping when doing GC?}
\begin{algorithmic}[1]
\setcounter{ALG@line}{1}
\Statex \linecomment{Shared variable}
\begin{itemize}
\item \typ{Node} \var{root} \Comment{root of a binary tree of \tt{Node}s with one leaf for each process}
\end{itemize}

\Statex \linecomment{Thread-local variable}
\begin{itemize}
\item \typ{Node} \var{leaf} \Comment{process's leaf in the tree}
\end{itemize}

\Statex $\blacktriangleright$ \typ{Node}
\begin{itemize}
\item \typ{Node} \fld{left}, \fld{right}, \fld{parent} \Comment{children and parent pointers initialized  when creating the tree}
\item \typ{Block}[0..$\infty$] \fld{blocks} \Comment{initially \var{blocks}[0] contains an empty block with all integer fields equal to 0}
\item \typ{int} \head \Comment{position to attempt appending next \block\ to \fld{blocks}, initially 1}
\end{itemize}

\Statex $\blacktriangleright$ \typ{Block} 

\begin{itemize}
  	\item \typ{int} \fld{sum\sub{enq}, sum\sub{deq}}
  		\Comment{number of enqueue, dequeue operations in \fld{blocks} array up to this block (inclusive)}
  	\item \typ{int} \fld{super}
  		\Comment{approximate index of the block's superblock in \fld{parent.blocks}}
	\item[\com] Blocks in internal \nodes\ have the following additional fields
	\item \typ{int} \eleft, \eright
  		\Comment{index of last direct subblock in the left and right child}
  	\item[\com] Blocks in leaf \nodes\ have the following additional field
  	\item \typ{Object} \fld{element}
  		\Comment{if the block's operation is \opa{Enqueue}{x} then \fld{element}=\var{x}, otherwise \fld{element}=\nl}
	\item[\com] Blocks in the root \node\ have the following additional field
	\item \typ{int} \size%
  		\Comment{size of the queue after performing all operations up to the end of this block}
\end{itemize}

%\Statex {\com\  Blocks in internal nodes have the following additional fields}
%\Statex $\blacktriangleright$ \tt{\sl{InternalBlock} extends \sl{Block}} \sf{\com\ the following additional fields are used only for blocks in internal nodes}
%\begin{itemize}
%	\item \tt{int} \eleft, \eright
%  		\Comment{index of last direct subblock in the left and right child}
%\end{itemize}

%\Statex {\com\ Blocks in leaf nodes have the following additional field}
%\Statex $\blacktriangleright$ \tt{\sl{LeafBlock} extends \sl{Block}} \sf{\com\ the following additional field is used only for blocks in leaves}
%\begin{itemize}
%  \item \tt{\sl{Object} element}
%  \Comment{if the block's operation is \tt{enqueue(x)} then \tt{element=x}, otherwise \tt{element=null}.}
%\end{itemize}

%\Statex {\com\ Blocks in the root node have the following additional field}
%\Statex $\blacktriangleright$ \tt{\sl{RootBlock} extends \sl{InternalBlock}} \sf{\com\ the following additional field is used only for blocks in the root}
%\begin{itemize}
%  \item \tt{\sl{int} \size}%
%  \Comment{size of the queue after performing all operations up to the end of this block}
%\end{itemize}

\end{algorithmic}
\caption{Objects used in tournament tree data structure \label{object-fields}}
\end{figure}

\subsection{Details of the Implementation}

We now discuss the queue implementation in more detail.  Pseudocode is provided in Figure \ref{pseudocode1} and \ref{pseudocode2}.
%We use $v.\var{blocks[i].num\sub{enq}}$ as shorthand for 
%$v.\var{blocks[i].sum\sub{enq} - blocks[i-1].sum\sub{enq}}$, that is, 
%the number of enqueues in the block.  (For $\var{i}=0$, $v.\var{blocks[0].num\sub{enq}} = 0$.)
%We use \var{num\sub{deq}} similarly.
%\here{Check if the num abbreviation is really needed in the code--how many times do we use it?}

\renewcommand{\algorithmiccomment}[1]{\hfill\eqparbox{COMMENTDOUBLE}{\com\ #1}}
\newcommand{\hangbox}[1]{\parbox[t]{\dimexpr\linewidth-\algorithmicindent\relax}{%
    \setlength{\hangindent}{\algorithmicindent}%
    #1}}
\newcommand{\spac}{\medskip}
\newcommand{\assign}{\mbox{:=}}

\begin{figure}
\begin{minipage}[t]{0.465\textwidth}
\begin{algorithmic}[1]
\setcounter{ALG@line}{0}

\Function{void}{Enqueue}{\typ{Object} \var{e}} 
    \State \hangbox{let \var{n} be a new \typ{Block} with \fld{element} \assign\ \var{e},\\
		\fld{sum\sub{enq}} \assign\ \var{leaf}.\fld{blocks}[\var{leaf}.\head-1].\fld{sum\sub{enq}}+1,\\
		\fld{sum\sub{deq}} \assign\ \var{leaf}.\fld{blocks}[\var{leaf}.\head-1].\fld{sum\sub{deq}}}
    \State \Call{Append}{\var{n}}
\EndFunction{Enqueue}

\spac

\Function{Object}{Dequeue()}{} 
    \State \hangbox{let \var{n} be a new \typ{Block} with \fld{element} \assign\ \nl,\\
	    \fld{sum\sub{enq}} \assign\ \var{leaf}.\fld{blocks}[\var{leaf}.\head-1].\fld{sum\sub{enq}},\\
	    \fld{sum\sub{deq}} \assign\ \var{leaf}.\fld{blocks}[\var{leaf}.\head-1].\fld{sum\sub{deq}}+1}
    \State \Call{Append}{\var{n}}
    \State $\langle \var{b}, \var{i}\rangle$ \assign\ \Call{IndexDequeue}{\var{leaf}, \var{leaf}.\head, 1}
    \State \Return{ \Call{FindResponse}{\var{b, i}}}
    \label{deqRest}
\EndFunction{Dequeue}

\spac

\Function{void}{Append}{\typ{Block} \var{B}} 
    \State \linecomment{append block to leaf and propagate to root}
    \State \var{leaf}.\fld{blocks}[\var{leaf}.\head] \assign\ \var{B}\label{appendLeaf}
    \State \var{leaf}.\head\ \assign\ \var{leaf}.\head+1 \label{appendEnd} 
    \State \Call{Propagate}{\var{leaf}.\fld{parent}} 
\EndFunction{Append}

\spac

\Function{void}{Propagate}{\typ{Node} \var{v}}
    \State \linecomment{propagate blocks from \var{v}'s children to root}
    \If{\bf{not} \Call{Refresh}{\var{v}}} \label{firstRefresh}  \hfill \com\ double refresh
        \State \Call{Refresh}{\var{v}} \label{secondRefresh}
    \EndIf
    \If{\var{v} \bf{is not} \var{root}} \hfill \com\ recurse up tree
        \State \Call{Propagate}{\var{v}.\fld{parent}}
    \EndIf
\EndFunction{Propagate}

\spac

\Function{boolean}{Refresh}{\typ{Node} \var{v}}
    \State \linecomment{try to append a new block to \var{v}.\fld{blocks}}
    \State \var{h} \assign\ \var{v}.\head \label{readHead}
    \ForEach{\fld{dir} {\keywordfont{in}} \fld{\{left, right\}}} \label{startHelpChild1}
        \State \var{childHead} \assign\ \var{v}.\fld{dir}.\head \label{readChildHead}
        \If{\var{v}.\fld{dir.blocks}[\var{childHead}] $\neq$ \nl} \label{ifHeadnotNull}
            \State \Call{Advance}{\var{v}.\fld{dir}, \var{childHead}} \label{helpAdvance}
        \EndIf
    \EndFor \label{endHelpChild1}
    \State \var{new} \assign\ \Call{CreateBlock}{\var{v, h}} \label{invokeCreateBlock}
    \If{\var{new = \nl}} \Return{\tr} \label{addOP} 
    \EndIf
    \State \var{result} \assign\ \Call{CAS}{\var{v}.\fld{blocks}[\var{h}], \nl, \var{new}} \label{cas}
    \State \var{\Call{Advance}{\var{v, h}}}\label{advance}
    \State \Return{ \var{result}}
\EndFunction{Refresh}

\spac

\Function{void}{Advance}{\typ{Node} \var{v}, \typ{int} \var{h}} 
    \State \linecomment{set \var{v}.\fld{blocks}[\var{h}].\fld{super} and }
    \State \linecomment{increment \var{v}.\fld{head} from \var{h} to \var{h}+1}
    \State \var{h\sub{p}} \assign\ \var{v}.\fld{parent}.\head \label{readParentHead}
    \State \Call{CAS}{\var{v}.\fld{blocks}[\var{h}].\fld{super}, \nl, \var{h\sub{p}}} \label{setSuper1}
    \State \Call{CAS}{\var{v}.\head, \var{h}, \var{h}+1} \label{incrementHead}
\EndFunction{Advance}

\end{algorithmic}
\end{minipage}
\begin{minipage}[t]{0.529\textwidth}

\begin{algorithmic}[1]
\setcounter{ALG@line}{48}

\Function{Block}{CreateBlock}{\typ{Node} \var{v}, \typ{int} \var{i}} 
    \State\linecomment{create new block for a \op{Refresh} to install in \var{v}.\fld{blocks}[\var{i}]}
    \State let \var{new} be a new \typ{Block} \label{initNewBlock}
    \State \var{new}.\eleft \assign\ $\var{v}.\fld{left}.\head - 1$\label{createEndLeft}
    \State \var{new}.\eright \assign\ $\var{v}.\fld{right}.\head - 1$
	\State \hangbox{\var{new}.\fld{sum\sub{enq}} \assign\ \var{v}.\fld{left.blocks}[\var{new}.\eleft].\fld{sum\sub{enq}} + \\
			\var{v}.\fld{right.blocks}[\var{new}.\eright].\fld{sum\sub{enq}}}
	\State \hangbox{\var{new}.\fld{sum\sub{deq}} \assign\ \var{v}.\fld{left.blocks}[\var{new}.\eleft].\fld{sum\sub{deq}} + \\
			\var{v}.\fld{right.blocks}[\var{new}.\eright].\fld{sum\sub{deq}}}
    \State \var{num\sub{enq}} \assign\ $\var{new}.\fld{sum\sub{enq}} - \var{v}.\fld{blocks}[\var{i}-1].\fld{sum\sub{enq}}$\label{computeNumEnq}
    \State \var{num\sub{deq}} \assign\ $\var{new}.\fld{sum\sub{deq}} - \var{v}.\fld{blocks}[\var{i}-1].\fld{sum\sub{deq}}$
    \If{$\var{v} = \var{root}$}
        \State \hangbox{\var{new}.\fld{size} \assign\ max(0, $\var{v}.\fld{blocks}[\var{i}-1].\size\ + \var{num\sub{enq}} - \var{num\sub{deq}}$)}\label{computeLength}
    \EndIf
    \If{$\var{num\sub{enq}} + \var{num\sub{deq}} = 0$}
        \State \Return \nl \hfill \com\ no blocks need to be propagated to \var{v}
    \Else
        \State \Return \var{new}
    \EndIf
\EndFunction{CreateBlock}

\spac

\Function{$\langle\typ{int}, \typ{int}\rangle$}{IndexDequeue}{\typ{Node} \var{v}, \typ{int} \var{b}, \typ{int} \var{i}}
    \State \linecomment{return $\langle\var{x, y}\rangle$ such that \var{i}th dequeue in $D(\var{v}.\fld{blocks}[\var{b}])$}
    \State \linecomment{is \var{y}th dequeue of $D(\var{root}.\fld{blocks}[\var{x}])$}
    \State \linecomment{Precondition: \var{v}.\fld{blocks}[\var{b}] has been propagated to root}
    \State \linecomment{and $D(\var{v}.\fld{blocks}[\var{b}])$ has at least \var{i} dequeues}
    \If{$\var{v} = \var{root}$}
        \State\Return $\langle\var{b, i}\rangle$ \label{indexBaseCase}
    \Else
	    \State \fld{dir} \assign\ (\var{v}.\fld{parent.left} = \var{v} ? \fld{left} : \fld{right}) 
    	\State \var{sup} \assign\ \var{v}.\fld{blocks}[\var{b}].\fld{super}
	    \If{$\var{b} > \var{v}.\fld{parent.blocks}[\var{sup}].\fld{end\sub{dir}}$}
	        \State{\var{sup} \assign\ $\var{sup}+1$}
	    \EndIf
	    \State \linecomment{compute index \var{i} of dequeue in superblock}
	    \State \hangbox{\var{i} += $\var{v}.\fld{blocks}[\var{b}-1].\fld{sum\sub{deq}} -$ \\
	    		$\var{v}.\fld{blocks}[\var{v}.\fld{parent.blocks}[\var{sup}-1].\edir].\fld{sum\sub{deq}}$}
        \If{$\fld{dir} = \fld{right}$} 
        	\State \hangbox{\var{i} += $\var{v}.\fld{blocks}[\var{v}.\fld{parent.blocks}[\var{sup}].\eleft].\fld{sum\sub{deq}} - \mbox{ }$\\
					$\var{v}.\fld{blocks}[\var{v}.\fld{parent.blocks}[\var{sup}-1].\eleft].\fld{sum\sub{deq}}$}\label{considerLeftBeforeRight}
        \EndIf \label{computeISuperEnd}
        \State \Return\Call{IndexDequeue}{\var{v}.\fld{parent}, \var{sup}, \var{i}}
    \EndIf
\EndFunction{IndexDequeue}

\spac

\Function{element}{FindResponse}{\typ{int} \var{b}, \typ{int} \var{i}}
    \State \linecomment{find response to \var{i}th dequeue in \var{root}.\fld{blocks}[\var{b}]}
    \State \hangbox{\var{num\sub{enq}} \assign\ $\var{root}.\fld{blocks}[\var{b}].\fld{sum\sub{enq}} - \mbox{ }$\\
    		$\var{root}.\fld{blocks}[\var{b}-1].\fld{sum\sub{enq}}$}
    \If{$\var{root}.\fld{blocks}[\var{b}-1].\size + \var{num\sub{enq}} < \var{i}$}\label{checkEmpty}
        \State \Return \nl \hfill \com\ queue is empty when dequeue occurs\label{returnNull}
    \Else \ \linecomment{response is the \var{e}th enqueue in the root}
        \State \var{e} \assign\ \var{i} + \var{root}.\fld{blocks}[\var{b}-1].\fld{sum\sub{enq}} - 
			\var{root}.\fld{blocks}[\var{b}-1].\size\label{computeE}
		\State \linecomment{compute enqueue's block using binary search}
		\State find min $\var{b}'\leq \var{b}$ with $\var{root}.\fld{blocks}[\var{b}'].\fld{sum\sub{enq}} \geq \var{e}$
		\State \linecomment{find rank of enqueue within its block}
		\State $\var{i}' \assign\ \var{e} - \var{root}.\fld{blocks}[\var{b}'-1].\fld{sum\sub{enq}}$
        \State \Return \Call{GetEnqueue}{\var{root}, $\var{b}'$, $\var{i}'$}\label{findAnswer}
    \EndIf
\EndFunction{FindResponse}


\end{algorithmic}
\end{minipage}
\caption{Queue implementation.\label{pseudocode1}}
\end{figure}



%\begin{algorithm}
%\caption{\tt{\sl{Node}}}
%\begin{algorithmic}[1]
%\setcounter{ALG@line}{25}
%
%\Statex $\leadsto$ \textsf{Precondition: \tt{blocks[start..end]} contains a block with \tt{sum\sub{enq}} greater than or equal to \tt{x}}
%\Statex \com\ \textmd{Does a binary search for~the value \tt{x} of \tt{sum\sub{enq}} field and returns the index of the leftmost block in\\
%\com\ \tt{blocks[start..end]} whose \tt{sum\sub{enq}} is $\geq$ \tt{x}}.
%\Function{int}{BinarySearch}{\sl{int} x, \sl{int} start, \sl{int} end}
% \State \Return \tt{min\{j: blocks[j].sum\sub{enq}$\geq$x\}}
%\While{\nf{start<end}}
%\State \tt{\sl{int}} \tt{mid \assign\ floor((start+end)/2)}
%\If{\nf{blocks[mid].sum\sub{enq}<x}}
%\State \nf{start \assign\ mid+1}
%\Else
%\State \nf{end \assign\ mid}
%\EndIf
%\EndWhile
%\State\Return \nf{start}
%\EndFunction{BinarySearch}
%
%\end{algorithmic}
%\end{algorithm}

%\begin{algorithm}
%\caption{\tt{\sl{Root}}}
%\begin{algorithmic}[1]
%\setcounter{ALG@line}{36}
%\Statex
%\Statex $\leadsto$ \textsf{Precondition: \tt{root.blocks[end].sum\sub{enq} $\geq$ \tt{e}}}
%\Statex \com\ \textmd{Returns \tt{<b,i>} such that $E_\nf{e}(\nf{root})$ is $E_\nf{i}(\nf{root},\nf{b})$, i.e., the \nf{e}th \nf{Enqueue} in the \nf{root} is the \nf{i}th \nf{Enqueue} within \\
%\com\ the \nf{b}th block in the \nf{root}.}
%
%\Function{<int, int>}{DoublingSearch}{\sl{int} e, \sl{int} end}
%\State \tt{start \assign\ end-1} \label{dsearchStart}
%\While{\tt{root.blocks[start].sum\sub{enq}}$\geq$\tt{e}}
%\State \tt{start \assign\ max(start-(end-start), 0)} \label{doubling}
%\EndWhile \label{dsearchEnd}
%\State \tt{b \assign\ root.BinarySearch(e, start, end)} \label{dsearchBinarySearch}
%\State \tt{i \assign\ e- root.blocks[b-1].sum\sub{enq}} \label{DSearchComputei}
%\State\Return \tt{<b,i>}
%\EndFunction{DoublingSearch}
%\end{algorithmic}
%\end{algorithm}


\begin{figure}
\begin{algorithmic}[1]
\setcounter{ALG@line}{101}

\Function{element}{GetEnqueue}{\typ{Node} \var{v}, \typ{int} \var{b}, \typ{int} \var{i}} \Comment{returns argument of \var{i}th enqueue in $E(\var{v}.\fld{blocks}[\var{b}])$}
    \State \linecomment{Precondition: $\var{i}\geq 1$ and $E(\var{v}.\fld{blocks}[\var{b}])$ contains at least \var{i} enqueues}

    \If{\var{v} is a leaf node}
        \State\Return \var{v}.\fld{blocks}[\var{b}].\fld{element} \label{getBaseCase}
    \Else 
        \State \var{sum\sub{left}} \assign\ \var{v}.\fld{left.blocks}[\var{v}.\fld{blocks}[\var{b}].\eleft].\fld{sum\sub{enq}} \Comment{\#\ of enqueues in \var{v}.\fld{blocks}[1..$\var{b}$] from left child}
        \State \var{prev\sub{left}} \assign\ \var{v}.\fld{left.blocks}[\var{v}.\fld{blocks}[$\var{b}-1$].\eleft].\fld{sum\sub{enq}} \Comment{\#\ of enqueues in \var{v}.\fld{blocks}[1..$\var{b}-1$] from left child}
        \State \var{prev\sub{right}} \assign\ \var{v}.\fld{right.blocks}[\var{v}.\fld{blocks}[$\var{b}-1$].\eright].\fld{sum\sub{enq}} \Comment{\#\ of enqueues in \var{v}.\fld{blocks}[1..$\var{b}-1$] from right child}
        \If{$\var{i} \leq \var{sum\sub{left}} - \var{prev\sub{left}}$} \label{leftOrRight} \cmt{required enqueue is in \var{v}.\fld{left}}
            \State \fld{dir} \assign\ \fld{left}
        \Else
            \State \fld{dir} \assign\ \fld{right}
            \State $\var{i}\ \assign\ \var{i} - (\var{sum\sub{left}} - \var{prev\sub{left}})$
        \EndIf
        \State \linecomment{Use binary search to find enqueue's block in \var{v}.\fld{dir} and its rank within block}
        \State find minimum $\var{b}'$ in range [\var{v}.\fld{blocks}[\var{b}-1].\edir+1..\var{v}.\fld{blocks}[\var{b}].\edir] s.t. $\var{v}.\fld{dir.blocks}[\var{b}'].\fld{sum\sub{enq}} \geq \var{i} + \var{prev\sub{dir}}$\label{getChild}
        \State $\var{i}'$ \assign\ $\var{i} - (\var{v}.\fld{dir.blocks}[\var{b}'-1].\fld{sum\sub{enq}} - \var{prev\sub{dir}})$
        \State \Return\Call{GetEnqueue}{\var{v}.\fld{dir}, $\var{b}'$, $\var{i}'$} 
    \EndIf
\EndFunction{GetEnqueue}
\end{algorithmic}
\caption{\label{pseudocode2}Queue implementation, continued. \here{Would this routine be simpler to write if i parameter was the rank within whole node rather than within the block?}}
\end{figure}

An \opemph{Enqueue}(\var{e}) appends a \block\ to the process's leaf.
The block has $\fld{element}=\var{e}$ to indicate it represents an \op{Enqueue}(\var{e}) operation.
It suffices to propagate the operation to the root and
then use its position in the linearization for future \nf{Dequeue}
operations.

A \opemph{Dequeue} also appends a \block\ to the process's leaf.
The block has $\fld{element}=\nl$ to indicate that it represents a \op{Dequeue} operation.
After propagating the operation to the root, it computes
its position in the root using
\nf{IndexDequeue} and then computes its response by calling \nf{FindResponse}. 

\opemph{Append}(\var{B}) first adds the block \var{B} to the invoking process's leaf.
The leaf's \fld{head} field stores the first empty slot in the leaf's \fld{blocks} array,
so the \op{Append} writes \var{B} there and increments \fld{head}.
Since \op{Append} writes only to the process's own leaf, there cannot be concurrent updates to a leaf.
\op{Append} then calls \op{Propagate} to ensure the operation represented by \var{B} is propagated to the root.

\opemph{Propagate}(\var{v}) guarantees that any blocks that are in \var{v}'s children when \op{Propagate} is invoked are propagated to the root.
It uses the double refresh idea described
above and invokes two \op{Refresh}es on \var{v} in Lines
\ref{firstRefresh} and \ref{secondRefresh}. 
If both fail to add a block to \var{v}, it means some other process has done a successful \op{Refresh}
that propagated blocks from \var{v}'s children to \var{v}.
Then, \op{Propagate} recurses to \var{v}.\fld{parent} to continue propagating blocks up to the root.  

%\paragraph{\tt{Refresh()} and \tt{Advance()}}
The goal of a \opemph{Refresh} on node \var{v} is to create a block representing the new blocks
in \var{v}'s
children and append it to \var{v}.\fld{blocks}. 
Line \ref{readHead} reads \var{v}.\fld{head} into the local variable \var{h}
and Line \ref{invokeCreateBlock} creates the new block to be installed in \var{v}.\fld{blocks}[\var{h}].
If line \ref{invokeCreateBlock} returns \nl\ instead of a new block, it means that there were no new blocks in \var{v}'s children to propagate to \var{v},
so \op{Refresh} terminates and returns true at line \ref{addOP}.
Otherwise, the CAS at line \ref{cas} attempts to install its new block into \var{v}.\fld{blocks}[\var{h}].
Either this CAS succeeds or some other process has installed a new block in this location.
Either way, line \ref{advance} then calls \opemph{Advance} to advance \var{v}'s head pointer 
from \var{h} to $\var{h}+1$
and to fill in the \fld{super} field of the most recently appended block.
The boolean value returned by \op{Refresh} indicates whether its CAS succeeded.
Since a \op{Refresh} may do a successful CAS but pause before calling \op{Advance} at line \ref{advance},
other processes help keep \fld{head} up to date by also calling \op{Advance}, 
either at line \ref{helpAdvance} during a \op{Refresh} on \var{v}'s parent or line \ref{advance} during a \op{Refresh} on \var{v}.

\opemph{CreateBlock}(\var{v, i}) is used
by \op{Refresh} to construct a block to be installed in \var{v}.\fld{blocks}[\var{i}].
The block \nf{new} is created in Line \ref{initNewBlock}. 
The \eleft\ and \eright\ fields are filled in with the indices of the last blocks appended to \var{v}'s
children, which are obtained by reading the \fld{head} index in \var{v}'s children.
Recall that the \fld{sum\sub{enq}} field should store the number of enqueues in
\var{v}.\fld{blocks}[1..\var{i}].
Since these enqueues come from \var{v}.\fld{left.blocks}[1..\var{new}.\eleft] and \var{v}.\fld{blocks}[1..\var{new}.\eright],
the total number of these enqueues is $\var{v}.\fld{left.blocks}[\var{new}.\eleft].\fld{sum\sub{enq}} + \var{v}.\fld{right}.\fld{blocks}[\var{new}.\eright].\fld{sum\sub{enq}}$.
Line \ref{computeNumEnq} sets \var{num\sub{enq}} to the number of enqueues in the new block by
subtracting from \var{new}.\fld{sum\sub{enq}} the number of enqueues that are already in \var{v}.\fld{blocks}[$1..\var{i}-1$].
The values of \var{new}.\fld{sum\sub{deq}} and \var{num\sub{deq}} are computed similarly.
Then, if \var{new}
is going to be installed in the root, line \ref{computeLength} computes the \fld{size} field, which
represents the number of elements in the queue after the operations in the block are performed.
Finally, if the newly created block contains no operations, \op{CreateBlock} returns \nl\ to indicate
that there is no need to append it to \var{v}.\fld{blocks}.

Once a \op{Dequeue} has been appended to a block of the process's leaf and propagated to the root,
the \opemph{IndexDequeue} routine is used to find the \op{Dequeue}'s location in the root.
More precisely, \opa{IndexDequeue}{v, b, i}
computes the block in the root and the rank
within that block  of the \var{i}th \op{Dequeue} of the block \var{B} stored in \var{v}.\fld{blocks}[\var{b}].
Let $R\sub{\var{v}}$ be the successful \nf{Refresh} on node \var{v}
whose CAS wrote a block \var{B} into \var{v}.\fld{blocks}[\var{b}].
Let $par$ be \var{v}.\fld{parent}. Without loss of generality, assume 
\var{v} is the left child of $par$. Let
$R_{par}$ be the first successful \op{Refresh} on $par$ whose \op{CreateBlock} reads a
value greater than \var{b} from $\var{par}.\fld{left.head}=\var{v}.\fld{head}$ at line \ref{createEndLeft} and therefore creates a block $B'$ that contains
\var{B} as a subblock. 
%Let $b'$ be the index of $B'$ in $par$.\fld{blocks}. 
 
Since the index of \var{B}'s superblock is not known until $B$ is
propagated to $par$, $R_v$ cannot set the \nf{super} field of ${B}$ when
it creates \var{B}. 
It would be too costly to have $R_{par}$ set the \fld{super} field of all the direct subblocks of $B'$ (because
there could be up to $p$ direct subblocks).
Intuitively, the index of \var{B}'s superblock will be close to the value of \var{par}.\fld{head} has when \var{B} is installed.
Since we can search for the precise superblock when we need it, it suffices that \var{B}.\fld{super}
is close to the actual index of \var{B}'s superblock.
Thus, after \var{B} is installed, the call to \op{Advance} at line \ref{advance} sets the value of \var{B}.\fld{super} by reading \var{par}.\fld{head}.
As mentioned earlier, other processes may help fill in this field by calling \op{Advance} at line \ref{helpAdvance} or \ref{advance} to ensure that it is filled in soon after \var{B} is installed.
We shall
show that this ensures that \nf{$B$.super} differs
from the index of $B'$ by at most~1. 

To compute the response of the $i$th \nf{Dequeue} in the $b$th block
of the root, \opemph{FindResponse}(\var{b, i}) determines at line \ref{checkEmpty} if the queue is empty.
If the queue is
not empty, Line \ref{computeE} computes the rank \var{e} of the
\nf{Enqueue} whose argument is the response to the
\nf{Dequeue}. 
A binary search is used on the \fld{sum\sub{enq}} fields of \var{root}.\fld{blocks} to find the index $b'$ of the block that contains 
the \var{e}th enqueue.
The index $b'$ is at most $b$ (since the enqueue is linearized before the dequeue).  To find the left end of the range for the binary search for $b'$, we can first do a doubling search \cite{BY76}, comparing \var{e} to the \fld{sum\sub{enq}} fields at indices $b-1, b-2, b-4, b-8, \ldots$.
Then, \op{GetEnqueue} is used to trace down through the tree to find the required enqueue in a leaf.

\opemph{GetEnqueue}(\var{v,b,i}) returns the argument of the
$i$th enqueue in the $b$th block of \typ{Node} $v$. 
The range of subblocks of a block is determined using the \fld{end\sub{left}} and
\fld{end\sub{right}} fields of the block and its previous block. Then,
the exact subblock is found using binary search on the \fld{sum\sub{enq}}
field (line \ref{getChild}). 
\here{explain a little more?}



