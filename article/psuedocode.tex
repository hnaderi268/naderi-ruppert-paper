\documentclass[10pt]{article}
\renewcommand{\baselinestretch}{1.8}

\usepackage[b4paper,left=0.8in,right=0.8in,top=0.8in,bottom=0.8in]{geometry}
\usepackage{tikz-qtree}
\usepackage{algorithm}
\usepackage{algpseudocode}
\makeatletter
\renewcommand{\ALG@beginalgorithmic}{\footnotesize}
\makeatother
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{showkeys}
\usepackage{amsmath}


\usepackage{multicol}
\setlength\columnsep{24pt}

\algnewcommand\algorithmicforeach{\bf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\algdef{S}[FUNCTION]{Function}
   [3]{{\tt{\sl{#1}}} \textproc{\tt{#2}}\ifthenelse{\equal{#3}{}}{}{\tt{(#3)}}}
  
\algdef{E}[FUNCTION]{EndFunction}
   [1]{\algorithmicend\ \tt{\textproc{#1}}}

\algrenewcommand\Call[2]{\tt{\textproc{#1}\ifthenelse{\equal{#2}{}}{}{(#2)}}}
   
\newcommand\keywordfont{\sffamily\bfseries}
\algrenewcommand\algorithmicend{{\keywordfont end}}
\algrenewcommand\algorithmicfor{{\keywordfont for}}
\algrenewcommand\algorithmicforeach{{\keywordfont for each}}
\algrenewcommand\algorithmicdo{{\keywordfont do}}
\algrenewcommand\algorithmicuntil{{\keywordfont until}}
\algrenewcommand\algorithmicfunction{{\keywordfont function}}
\algrenewcommand\algorithmicif{{\keywordfont if}}
\algrenewcommand\algorithmicthen{{\keywordfont then}}
\algrenewcommand\algorithmicelse{{\keywordfont else}}
\algrenewcommand\algorithmicreturn{{\keywordfont return}}

\renewcommand\thealgorithm{}
\newcommand{\setalglineno}[1]{%
  \setcounter{ALC@line}{\numexpr#1-1}}

\newcommand{\sub}[1]{\textsubscript{#1}}
\renewcommand{\tt}[1]{\texttt{#1}}
\renewcommand{\sl}[1]{\textsl{#1}}
\renewcommand{\it}[1]{\textit{#1}}
\renewcommand{\bf}[1]{\textbf{#1}}
\newcommand{\cmt}[1]{\Comment{#1}}

\usepackage{amsmath,amssymb,amsthm}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\begin{document}

\begin{algorithm}
\caption{Queue \label{algQ}}
\begin{algorithmic}[1]
\begin{multicols}{2}

%\Statex \bf{Structure}

\Statex $\diamondsuit$ \tt{\sl{Local}}
\begin{itemize}
\item \tt{\sl{*Node} leaf\textsf{: pointer the the process's leaf in the tree}}
\end{itemize}

\Statex

\Statex $\diamondsuit$ \tt{\sl{Shared}}
\begin{itemize}
\item \tt{\sl{Tree}} \textsf{: A binary tree of \tt{Node}s is shared among the processes. It can be implemented with a 1 index based array of size $p$. Such that the root is index 1, the left child and the right child of a node with index i are indices 2i, 2i+1 in the array.}
\end{itemize}

\Statex
\Statex $\diamondsuit$ \tt{\sl{Structures}}

\Statex $\blacktriangleright$ \tt{\sl{Node}}
\begin{itemize}
\item \tt{\sl{*Node} left, right, parent}
\item \tt{\sl{Block[]} blocks}\textsf{: index 0 contains an empty block with all fields equal to 0 and \tt{en} pointers to the first block of the corresponding children. \tt{blocks[i]} returns the $i$th block stored.  In the root node it is implemented with a persistent red-black tree and it is a big array in the other nodes.}
\item \tt{\sl{int} head= 1}\textsf{: index of the first empty cell of \tt{blocks}}
\item \tt{\sl{int} counter= 0}\textsf{}
\item \tt{\sl{int[]} super}\textsf{: \tt{super[i]} stores the index of a superblock in parent that contains some block of this node whose \tt{time} is field \tt{i}}
\end{itemize}

\Statex $\blacktriangleright$ \tt{\sl{leaf} extends Node}
\begin{itemize}
  \item \tt{\sl{int[]} response}
  
  \textsf{leaf.response[i] stores response of leaf.ops[i]}
  
  \item \tt{\sl{int} \tt{last\sub{done}}}

  \textsf{Each process stores the index of the most recent block that the process has finished its last operation. An enqueue operation is finished if it has appended its element to the root and a dequeue operation is finished when it computes its response.}
  
\end{itemize}


\Statex $\blacktriangleright$ \tt{\sl{Block}}

\begin{itemize}
  \item \tt{\sl{int} num\sub{enq-left}, sum\sub{enq-left}}
  \textsf{:~~\#enqueues from subblocks in left child, prefix sum of \tt{num\sub{enq-left}}}
  \item \tt{\sl{int} num\sub{deq-left}, sum\sub{deq-left}}
  \textsf{:~~\#dequeues from subblocks in left child, prefix sum of \tt{num\sub{deq-left}}}
  \item \tt{\sl{int} num\sub{enq-right}, \tt{sum\sub{enq-right}}}
  \textsf{: ~\#enqueues from subblocks in right child, prefix sum of \tt{num\sub{enq-right}}}
  \item \tt{\sl{int} num\sub{deq-right}, \tt{sum\sub{deq-right}}}
  \textsf{: ~\#dequeues from subblocks in right child, prefix sum of \tt{num\sub{deq-right}}}
  \item \tt{\sl{int} num\sub{enq}, num\sub{deq}}
  \textsf{: \# enqueue, dequeue operations in the block}
  \item \tt{\sl{int} sum\sub{enq}, sum\sub{deq}}
  \textsf{: sum of \# enqueue, dequeue operations in blocks up to this one}
  \item \tt{\sl{int} num, sum}
  \textsf{: total \# operations in block, prefix sum of \tt{num}}
  \item \tt{\sl{int} end\sub{left}, end\sub{right}}
  \textsf{:~~index of the last subblock in the left and right child}
  \item \tt{\sl{int} group}
  \textsf{: id of the group of blocks including this propagated together, more precisely the value read from the node \tt{n}'s counter when propagating this block to the node \tt{n}.}
\end{itemize}

\pagebreak

\Statex $\blacktriangleright$ \tt{\sl{Leaf Block} extends \sl{Block}}
\begin{itemize}
  \item \tt{\sl{Object} element}
  \textsf{Each block in a leaf represents an operation. The \tt{element} shows the operation's argument if it is an enqueue, and if it is a dequeue this value is \tt{null}.}
\end{itemize}

\Statex $\blacktriangleright$ \tt{\sl{Root Block} extends \sl{Block}}
\begin{itemize}
  \item \tt{\sl{int} size}
  \textsf{: size of queue after this block's operations finish}
  \item \tt{\sl{int} sum\sub{non-null deq}}
  \textsf{: count of non-null dequeus up to this block}
  \item \tt{\sl{int} num\sub{finished}}
  \textsf{: number of finished operations in the block}
    \item \tt{\sl{int} order}
  \textsf{: the index of the block in the node containing it. Useful in the root since in the PBRT we do not keep indices in another way.}
\end{itemize}

\end{multicols}
\end{algorithmic}
\end{algorithm}


%##########################################


\begin{algorithm}
\begin{algorithmic}[1]
\setcounter{ALG@line}{33}
\begin{multicols}{2}

\Function{void}{Enqueue}{\sl{Object} e} \cmt{Creates a block with element \tt{e} and appends it to the tree.}
\State \tt{block b= \Call{new}{\sl{leaf block}}}
\State \tt{b.element= e}
\State \tt{b.num\sub{enq}=1}
\State \tt{b.sum\sub{enq}= this.leaf.blocks[this.leaf.head].sum\sub{enq}+1}
\State \Call{Append}{b}
\EndFunction{Enqueue}

\Statex
\Function{Object}{Dequeue()}{}
\State \tt{block b= \Call{new}{\sl{leaf block}}} \cmt{Creates a null element block, appends it to the tree, computes its order among operations, then computes its response index if it exists and returns the response's element.}
\State \tt{b.element= null}
\State \tt{b.num\sub{deq}=1}
\State \tt{b.sum\sub{deq}= this.leaf.blocks[this.leaf.head].sum\sub{deq}+1} \cmt{\tt{this} is the current running process}
\State \Call{Append}{b}
\State \tt{<i, b\sub{i}>=} \Call{Index}{this.leaf, this.leaf.head, 1} \cmt{\tt{i} is the order in the root among all dequeues, of the dequeue in the last block in the process's leaf. \tt{b\sub{i}} is the index of the block in the root containing it. Since only one invocation of \tt{dequeue} is running by \tt{this} process at one time we are allowed to used \tt{this.leaf.head} safely.}
\State \tt{index\sub{response}=} \Call{ComputeDeqRes}{i, b} \cmt{\tt{index\sub{response}} is the index of the enqueue which is the response to the dequeue or -1 if the response is \tt{null}.} \label{deqRest}
\If{\tt{index\sub{response}!=-1}}
\State \tt{output= null}
\State \tt{b\sub{deq}=root.blocks[b\sub{i}]}
\State \tt{b\sub{deq}.num\sub{finished}.inc()} \cmt{shared counter}
\If{\tt{b\sub{deq}.num\sub{finished}==b\sub{deq}.num}}\cmt{all the operations in the block containing the dequeue are finished.}
\State \tt{this.leaf.last\sub{done}= b\sub{i}}
\EndIf
\Else
\State \tt{output= \Call{Get}{index\sub{response}}}
\State \tt{b\sub{r}= root.blocks.get(enq, index\sub{response}).order}\cmt{index of the block in the root contains response enqueue.}
\State \tt{b\sub{enq}=root.blocks[b\sub{r}]}
\State \tt{b\sub{enq}.num\sub{finished}.inc()}
\State \tt{b\sub{deq}.num\sub{finished}.inc()}
\If{\tt{b\sub{enq}.num\sub{finished}==b\sub{enq}.num}}\cmt{become done}
\State \tt{this.leaf.last\sub{done}= b\sub{r}}
\ElsIf {\tt{b\sub{deq}.num\sub{finished}==b\sub{deq}.num}} \cmt{\tt{b\sub{deq}} comes after \tt{b\sub{enq}}.}
\State \tt{this.leaf.last\sub{done}= b\sub{i}} \cmt{\tt{this.leaf.last\sub{done}} is an increasing value.}
\EndIf
\EndIf
\State \Return{\tt{output}}
\EndFunction{Dequeue}



\Statex

\Function{void}{Append}{\sl{block} b} 
\State \tt{b.group= this.leaf.head} \label{appendStart} \cmt{Only this block is propagated from the leaf by itself.}
\State \tt{this.leaf.blocks[this.leaf.head]= b} 
\State \tt{this.leaf.head+=1} \label{appendEnd} \cmt{Lines \ref{appendStart} to \ref{appendEnd} are done by one process at time.}
\State \Call{Propagate}{this.leaf.parent} 
\EndFunction{Append}

\Statex

\Function{void}{Propagate}{\sl{node} n}
\If{\tt{not} \Call{Refresh}{n}}
\State \Call{Refresh}{n} \cmt{Lemma Double Refresh}
\EndIf
\If{\tt{n} \bf{is not} \tt{root}} \cmt{To check anode is the root we can check its index if the tree is implemented by an array or check if \tt{n.parent} is not \tt{null}.} 
\State \Call{Propagate}{n.parent}
\EndIf
\EndFunction{Propagate}

\Statex

\Function{element}{Get}{\sl{int} i}
\cmt{Returns $i$th Enqueue.}
\State \tt{res= root.blocks.get(enq, i).order}
\State \Return{\Call{Get}{root, res, i-root.blocks[res-1].sum\sub{enq}}}
\EndFunction{Get}

\Statex

\Function{int}{ComputeDeqRes}{int i, int b}\cmt{Computes the response of the \tt{i}th dequeue in the root's \tt{b}th block. Returns the index of the the head of the queue or -1 if queue is empty.}
\If{\tt{root.blocks[b-1].size + root.blocks[b].num\sub{enq} - i $<$ 0}}
\State \Return \tt{-1}
\Else{ \Return \tt{root.blocks[b-1].sum\sub{non-null deq} + i}}
\EndIf
\EndFunction{ComputeDeqRes}

\end{multicols}
\end{algorithmic}
\end{algorithm}


%##########################################


\begin{algorithm}
\begin{algorithmic}[1]
\setcounter{ALG@line}{33}
\begin{multicols}{2}

\Function{boolean}{Refresh}{\sl{node} n}
\State \tt{h= n.head}
%\If{\tt{n.blocks[h]!=null?}} \tt{h+=1}\EndIf
\State \tt{c= n.counter}
\State \tt{<new, c\sub{left}, c\sub{right}>= \Call{CreateBlock}{n, h}} \cmt{\tt{c\sub{left}, c\sub{right}} are the values read from \tt{n}'s children's counters.}
\State \tt{new.group= c}
\If{\tt{new.num==0}} \Return{\tt{true}} \cmt{The block contains nothing.}
\ElsIf{(\tt{n} \bf{is} \tt{root} \bf{and} \tt{root.blocks.append(new)}) \bf{or} \\ (\tt{n} \bf{is not} \tt{root} \bf{and} \Call{CAS}{n.blocks[h], null, new})} \cmt{\it{how to put space in he first of the new line?}}
\ForEach{\tt{dir} {\keywordfont{in}} \tt{\{left, right\}}} \label{okcas}
\State \tt{\Call{CAS}{n.dir.super[c\sub{dir}], null, h+1}} \cmt{Superblock's Lemma}
\State \tt{\Call{CAS}{n.dir.counter, c\sub{dir}, c\sub{dir}+1}}
\EndFor
\State \tt{\Call{CAS}{n.head, h, h+1}}
\State \Return{\tt{true}}
\Else
\State \tt{\Call{CAS}{n.head, h, h+1}} \cmt{Even if another process wins, help to increase the head. It might fell sleep before increasing.}
\State \Return{ \tt{false}}
\EndIf
\EndFunction{Refresh}

\Statex



\Statex $\leadsto$ \textsf{Precondition: \tt{n.blocks[start..end]} contains a block with field \tt{f} $\geq$ \tt{i}}
\Function{int}{BSearch}{\sl{node} n, \sl{field} f, \sl{int} i, \sl{int} start, \sl{int} end}

\Statex \cmt{\textmd{Does binary search for~the value \tt{i} of the given prefix sum \tt{feild}. Returns the index of the leftmost block in \tt{n.blocks[start..end]} whose \sl{field} \tt{f} is $\geq$ \tt{i}}.}
%\State \Return \tt{result block's index}
\EndFunction{BSearch}

\pagebreak

\Function{<Block, int, int>}{CreateBlock}{\sl{node} n, \sl{int} i} 
\Statex\cmt{Creates a block to insert into \tt{n.blocks[i]}. Returns the created block as well as values read from each child counter field. The values are used for incrementing children's counters if the block was appended to \tt{n.blocks} successfully. \it{Does it need help? I think no but in that case we do not have to pass these values to the calling line.}}
\State \tt{block b= \Call{new}{\sl{block}}}
\If{\tt{n} \bf{is} \tt{root}}
\State \tt{b= \Call{new}{\sl{root block}}}
\EndIf
\State \tt{b.order= i}
\ForEach{\tt{dir} {\keywordfont{in}} \tt{\{left, right\}}}
\State \tt{index\sub{last}= n.dir.head} \label{lastLine}
\State \tt{index\sub{prev}= n.blocks[i-1].end\sub{dir}} \label{prevLine}
\State \tt{block\sub{last}= n.dir.blocks[index\sub{last}]}
\State \tt{block\sub{prev}= n.dir.blocks[index\sub{prev}]} \cmt{\tt{n.dir.blocks[index\sub{prev}..index\sub{last}]} are merged to one block.}
\State \tt{c\sub{dir}= n.dir.counter}
\State \tt{b.end\sub{dir}= index\sub{last}}
\State \tt{b.num\sub{enq-dir}= block\sub{last}.sum\sub{enq} - block\sub{prev}.sum\sub{enq}}
\State \tt{b.num\sub{deq-dir}= block\sub{last}.sum\sub{deq} - block\sub{prev}.sum\sub{deq}}
\State \tt{b.sum\sub{enq-dir}= n.blocks[i-1].sum\sub{enq-dir} + b.num\sub{enq-dir}}
\State \tt{b.sum\sub{deq-dir}= n.blocks[i-1].sum\sub{deq-dir} + b.num\sub{deq-dir}}
\EndFor
\State \tt{b.num\sub{enq}= b.num\sub{enq-left} + b.num\sub{enq-right}}
\State \tt{b.num\sub{deq}= b.num\sub{deq-left} + b.num\sub{deq-right}}
\State \tt{b.num= b.num\sub{enq} + b.num\sub{deq}}
\State \tt{b.sum= n.blocks[i-1].sum + b.num}

\If{\tt{n} \bf{is} \tt{root}}
\State \tt{b.size= max(root.blocks[i-1].size + b.num\sub{enq} - b.num\sub{deq}, 0)}
\State \tt{b.sum\sub{non-null deq}= root.blocks[i-1].sum\sub{non-null deq} + max( b.num\sub{deq} - root.blocks[i-1].size - b.num\sub{enq}, 0)}
\EndIf

\State \Return \tt{b, c\sub{left}, c\sub{right}}
\EndFunction{CreateBlock}

\end{multicols}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\begin{algorithmic}[1]
\setcounter{ALG@line}{83}

\Statex $\leadsto$ \textsf{Precondition:~\tt{n.blocks[b]} contains $\geq$\tt{i} enqueues.}
\Function{element}{Get}{\sl{node} n, \sl{int} b, \sl{int} i} 
\cmt{\textmd{Returns the \tt{i}th Enqueue in \tt{b}th block of node \tt{n}}}
\If{\tt{n {\keywordfont is} leaf}} \Return \tt{n.blocks[b].element}
\Else
\If{\tt{i $\leq$ n.blocks[b].num\sub{enq-left}}} \cmt{\tt{i} exists in the left child of \tt{n}}
\State \tt{subBlock= \Call{BSearch}{n.left, sum\sub{enq}, i, n.blocks[b-1].end\sub{left}+1, n.blocks[b].end\sub{left}}}
\State \Return\Call{Get}{n.left, subBlock, i-n.left.blocks[subBlock-1].sum\sub{enq}} 
\Else
\State \tt{i= i-n.blocks[b].num\sub{enq-left}}
\State\tt{subBlock=\Call{BSearch}{n.right, sum\sub{enq}, i, n.blocks[b-1].end\sub{right}+1, n.blocks[b].end\sub{right}}}
\State \Return\Call{Get}{n.right, subBlock, i-n.right.blocks[subBlock-1].sum\sub{enq}} 
\EndIf
\EndIf
\EndFunction{Get}

\Statex
\Statex $\leadsto$ \textsf{Precondition: \tt{b}th block of node \tt{n} has propagated up to the root and \tt{i}th dequeue resides in node \tt{n} is in block \tt{b} of node \tt{n}.}
\Function{<int, int>}{Index}{\sl{node} n, \sl{int} b, \sl{int} i} \cmt{Returns the order in the root of $i$th dequeue in the $b$th block of node n among dequeues.}
\If{\tt{n {\keywordfont is} root}} \Return \tt{i, b}
\Else
\State \tt{dir= (n.parent.left==n)? left: right} \cmt{check \tt{n} is a left or a right child}
\State \tt{superBlock= \Call{BSearch}{n.parent, n.sum\sub{deq-dir}, i, super[n.blocks[b].group]-p, super[n.blocks[b].group]+p}} \cmt{superblock's group has at most $p$ difference with the value stored in \tt{super[]}.}
\If{\tt{dir {\keywordfont is} left}}
\State \tt{i+= n.parent.blocks[superBlock-1].sum\sub{deq-right}}
\Else \State \tt{i+= n.parent.blocks[superBlock-1].sum\sub{deq} + n.blocks[superBlock].sum\sub{deq-left}} \cmt{consider dequeues from \tt{n}'s right child}
\EndIf
\State \Return\Call{Index}{n.parent, superBlock, i}
\EndIf
\EndFunction{Index}

\end{algorithmic}
\end{algorithm}


%##########################################


\begin{algorithm}
\begin{algorithmic}[1]
\begin{multicols}{2}

\Statex $\blacktriangleright$ \tt{\sl{PRBTree[rootBlock]}}
  \Statex \textsf{A persistant red-black tree supporting \tt{append(b, key),get(key=i),split(j)}}.
  \tt{append(b, key)} returns \tt{true} in case successful. Since \tt{order, sum\sub{enq}}are both strictly increasing we can use one of them for another.



\Function{void}{RBTAppend}{block b} \cmt{\textsf{adds block b to the \tt{root.blocks}}}
\State \tt{step= root.head}
\If{\tt{step\%$p^2$==0}} \cmt{Help every often $p^2$ operations appended to the root. Used in lemma's using the size of the PBRT.}
\State \tt{Help()}
\State \tt{CollectGarbage()}
\EndIf
\State \tt{b.num\sub{finished}= 0}
\State \Return \tt{root.blocks.append(b, b.order)}
\EndFunction{RBTAppend}
\Statex


\Function{void}{Help}{}\cmt{Helps pending operations}
\For{\tt{leaf l} \bf{in leaves}}\cmt{\it{if the tree is implemented with an array we can iterate over the second half of the array.}}
\State{\tt{last= l.head-1}}
\cmt{\tt{l.blocks[last]} can not be \tt{null} because of lines \ref{appendStart}-\ref{appendEnd}.}
\If{\tt{l.blocks[last].element==null}} \cmt{operation is dequeue}
\State \tt{goto \ref{deqRest} with these values <>} \cmt{run \tt{Dequeue()}  for \tt{l.ops[last]} after Propagate(). \it{TODO}}
\State \tt{l.responses[last]= response}
\EndIf
\EndFor
\EndFunction{Help}
\Statex

\Function{void}{CollectGarbage}{}\cmt{Collects the root blocks that are done.}
\State \tt{s=FindMostRecentDone(Root.Blocks.root)}  \cmt{Lemma: If block b is done after helping then all blocks before b are done as well.}
\State \tt{t1,t2= RBT.split(order, s)}
\State \tt{RBTRoot.CAS(t2.root)}
\EndFunction{CollectGarbage}

\Statex

\Function{Block}{FindMostRecentDone}{b}
\For{\tt{leaf l} \bf{in leaves}}
\State\tt{max= Max(l.maxOld, max)}
\EndFor
\State\Return\tt{max} \cmt{This snapshot suffies.}
\EndFunction{findYoungestOld}

\Statex

\Function{response}{FallBack}{op i} \cmt{\it{really necessary?}}

\If{root.blocks.get(num\sub{enq}), i is null} \cmt{this enqueue was already finished}

\State \Return \tt{this.leaf.response(block.order)}
\EndIf

\EndFunction{FallBack}

\end{multicols}
\end{algorithmic}
\end{algorithm}




\end{document}






