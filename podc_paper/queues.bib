% !TEX root =  podc-submission.tex

% Journals

% First the Full Name is given, then the abbreviation used in the AMS Math
% Reviews, with an indication if it could not be found there.
% Note the 2nd overwrites the 1st, so swap them if you want the full name.

 %{AMS}
 @String{AMSTrans = "American Mathematical Society Translations" }
 @String{AMSTrans = "Amer. Math. Soc. Transl." }
 @String{BullAMS = "Bulletin of the American Mathematical Society" }
 @String{BullAMS = "Bull. Amer. Math. Soc." }
 @String{ProcAMS = "Proceedings of the American Mathematical Society" }
 @String{ProcAMS = "Proc. Amer. Math. Soc." }
 @String{TransAMS = "Transactions of the American Mathematical Society" }
 @String{TransAMS = "Trans. Amer. Math. Soc." }

 %ACM
 @String{CACM = "Communications of the {ACM}" }
 @String{CACM = "Commun. {ACM}" }
 @String{CompServ = "Comput. Surveys" }
 @String{JACM = "J. ACM" }
 @String{ACMMathSoft = "{ACM} Transactions on Mathematical Software" }
 @String{ACMMathSoft = "{ACM} Trans. Math. Software" }
 @String{SIGNUM = "{ACM} {SIGNUM} Newsletter" }
 @String{SIGNUM = "{ACM} {SIGNUM} Newslett." }

 @String{AmerSocio = "American Journal of Sociology" }
 @String{AmerStatAssoc = "Journal of the American Statistical Association" }
 @String{AmerStatAssoc = "J. Amer. Statist. Assoc." }
 @String{ApplMathComp = "Applied Mathematics and Computation" }
 @String{ApplMathComp = "Appl. Math. Comput." }
 @String{AmerMathMonthly = "American Mathematical Monthly" }
 @String{AmerMathMonthly = "Amer. Math. Monthly" }
 @String{BIT = "{BIT}" }
 @String{BritStatPsych = "British Journal of Mathematical and Statistical
          Psychology" }
 @String{BritStatPsych = "Brit. J. Math. Statist. Psych." }
 @String{CanMathBull = "Canadian Mathematical Bulletin" }
 @String{CanMathBull = "Canad. Math. Bull." }
 @String{CompApplMath = "Journal of Computational and Applied Mathematics" }
 @String{CompApplMath = "J. Comput. Appl. Math." }
 @String{CompPhys = "Journal of Computational Physics" }
 @String{CompPhys = "J. Comput. Phys." }
 @String{CompStruct = "Computers and Structures" }
 @String{CompStruct = "Comput. \& Structures" }
 @String{CompJour = "The Computer Journal" }
 @String{CompJour = "Comput. J." }
 @String{CompSysSci = "Journal of Computer and System Sciences" }
 @String{CompSysSci = "J. Comput. System Sci." }
 @String{Computing = "Computing" }
 @String{ContempMath = "Contemporary Mathematics" }
 @String{ContempMath = "Contemp. Math." }
 @String{Crelle = "Crelle's Journal" }
 @String{GiornaleMath = "Giornale di Mathematiche" }
 @String{GiornaleMath = "Giorn. Mat." } % didn't find in AMS MR., ibid.

 %IEEE
 @String{Computer = "{IEEE} Computer" }
 @String{IEEETransComp = "{IEEE} Transactions on Computers" }
 @String{IEEETransComp = "{IEEE} Trans. Comput." }
 @String{IEEETransAC = "{IEEE} Transactions on Automatic Control" }
 @String{IEEETransAC = "{IEEE} Trans. Automat. Control" }
 @String{IEEESpec = "{IEEE} Spectrum" } % didn't find in AMS MR
 @String{ProcIEEE = "Proceedings of the {IEEE}" }
 @String{ProcIEEE = "Proc. {IEEE}" } % didn't find in AMS MR
 @String{IEEETransAeroElec = "{IEEE} Transactions on Aerospace and Electronic
     Systems" }
 @String{IEEETransAeroElec = "{IEEE} Trans. Aerospace Electron. Systems" }

 @String{IMANumerAna = "{IMA} Journal of Numerical Analysis" }
 @String{IMANumerAna = "{IMA} J. Numer. Anal." }
 @String{InfProcLet = "Information Processing Letters" }
 @String{InfProcLet = "Inform. Process. Lett." }
 @String{InstMathApp = "Journal of the Institute of Mathematics and
     its Applications" }
 @String{InstMathApp = "J. Inst. Math. Appl." }
 @String{IntControl = "International Journal of Control" }
 @String{IntControl = "Internat. J. Control" }
 @String{IntNumerEng = "International Journal for Numerical Methods in
     Engineering" }
 @String{IntNumerEng = "Internat. J. Numer. Methods Engrg." }
 @String{IntSuper = "International Journal of Supercomputing Applications" }
 @String{IntSuper = "Internat. J. Supercomputing Applic." } % didn't find
%% in AMS MR
 @String{Kibernetika = "Kibernetika" }
 @String{JResNatBurStand = "Journal of Research of the National Bureau
     of Standards" }
 @String{JResNatBurStand = "J. Res. Nat. Bur. Standards" }
 @String{LinAlgApp = "Linear Algebra and its Applications" }
 @String{LinAlgApp = "Linear Algebra Appl." }
 @String{MathAnaAppl = "Journal of Mathematical Analysis and Applications" }
 @String{MathAnaAppl = "J. Math. Anal. Appl." }
 @String{MathAnnalen = "Mathematische Annalen" }
 @String{MathAnnalen = "Math. Ann." }
 @String{MathPhys = "Journal of Mathematical Physics" }
 @String{MathPhys = "J. Math. Phys." }
 @String{MathComp = "Mathematics of Computation" }
 @String{MathComp = "Math. Comp." }
 @String{MathScand = "Mathematica Scandinavica" }
 @String{MathScand = "Math. Scand." }
 @String{TablesAidsComp = "Mathematical Tables and Other Aids to Computation" }
 @String{TablesAidsComp = "Math. Tables Aids Comput." }
 @String{NumerMath = "Numerische Mathematik" }
 @String{NumerMath = "Numer. Math." }
 @String{PacificMath = "Pacific Journal of Mathematics" }
 @String{PacificMath = "Pacific J. Math." }
 @String{ParDistComp = "Journal of Parallel and Distributed Computing" }
 @String{ParDistComp = "J. Parallel and Distrib. Comput." } % didn't find
%% in AMS MR
 @String{ParComputing = "Parallel Computing" }
 @String{ParComputing = "Parallel Comput." }
 @String{PhilMag = "Philosophical Magazine" }
 @String{PhilMag = "Philos. Mag." }
 @String{ProcNAS = "Proceedings of the National Academy of Sciences
                    of the USA" }
 @String{ProcNAS = "Proc. Nat. Acad. Sci. U. S. A." }
 @String{Psychometrika = "Psychometrika" }
 @String{QuartMath = "Quarterly Journal of Mathematics, Oxford, Series (2)" }
 @String{QuartMath = "Quart. J. Math. Oxford Ser. (2)" }
 @String{QuartApplMath = "Quarterly of Applied Mathematics" }
 @String{QuartApplMath = "Quart. Appl. Math." }
 @String{RevueInstStat = "Review of the International Statisical Institute" }
 @String{RevueInstStat = "Rev. Inst. Internat. Statist." }

 %SIAM
 @String{JSIAM = "Journal of the Society for Industrial and Applied
     Mathematics" }
 @String{JSIAM = "J. Soc. Indust. Appl. Math." }
 @String{JSIAMB = "Journal of the Society for Industrial and Applied
     Mathematics, Series B, Numerical Analysis" }
 @String{JSIAMB = "J. Soc. Indust. Appl. Math. Ser. B Numer. Anal." }
 @String{SIAMAlgMeth = "{SIAM} Journal on Algebraic and Discrete Methods" }
 @String{SIAMAlgMeth = "{SIAM} J. Algebraic Discrete Methods" }
 @String{SIAMAppMath = "{SIAM} Journal on Applied Mathematics" }
 @String{SIAMAppMath = "{SIAM} J. Appl. Math." }
 @String{SIAMComp = "{SIAM} Journal on Computing" }
 @String{SIAMComp = "{SIAM} J. Comput." }
 @String{SIAMMatrix = "{SIAM} Journal on Matrix Analysis and Applications" }
 @String{SIAMMatrix = "{SIAM} J. Matrix Anal. Appl." }
 @String{SIAMNumAnal = "{SIAM} Journal on Numerical Analysis" }
 @String{SIAMNumAnal = "{SIAM} J. Numer. Anal." }
 @String{SIAMReview = "{SIAM} Review" }
 @String{SIAMReview = "{SIAM} Rev." }
 @String{SIAMSciStat = "{SIAM} Journal on Scientific and Statistical
     Computing" }
 @String{SIAMSciStat = "{SIAM} J. Sci. Statist. Comput." }

 @String{SoftPracExp = "Software Practice and Experience" }
 @String{SoftPracExp = "Software Prac. Experience" } % didn't find in AMS MR
 @String{StatScience = "Statistical Science" }
 @String{StatScience = "Statist. Sci." }
 @String{Techno = "Technometrics" }
 @String{USSRCompMathPhys = "{USSR} Computational Mathematics and Mathematical
     Physics" }
 @String{USSRCompMathPhys = "{U. S. S. R.} Comput. Math. and Math. Phys." }
 @String{VLSICompSys = "Journal of {VLSI} and Computer Systems" }
 @String{VLSICompSys = "J. {VLSI} Comput. Syst." }
 @String{ZAngewMathMech = "Zeitschrift fur Angewandte Mathematik und
     Mechanik" }
 @String{ZAngewMathMech = "Z. Angew. Math. Mech." }
 @String{ZAngewMathPhys = "Zeitschrift fur Angewandte Mathematik und Physik" }
 @String{ZAngewMathPhys = "Z. Angew. Math. Phys." }

% Publishers % ================================================= |

 @String{Academic = "Academic Press" }
 @String{ACMPress = "{ACM} Press" }
 @String{AdamHilger = "Adam Hilger" }
 @String{AddisonWesley = "Addison-Wesley" }
 @String{AllynBacon = "Allyn and Bacon" }
 @String{AMS = "American Mathematical Society" }
 @String{Birkhauser = "Birkha{\"u}ser" }
 @String{CambridgePress = "Cambridge University Press" }
 @String{Chelsea = "Chelsea" }
 @String{ClaredonPress = "Claredon Press" }
 @String{DoverPub = "Dover Publications" }
 @String{Eyolles = "Eyolles" }
 @String{HoltRinehartWinston = "Holt, Rinehart and Winston" }
 @String{Interscience = "Interscience" }
 @String{JohnsHopkinsPress = "The Johns Hopkins University Press" }
 @String{JohnWileySons = "John Wiley and Sons" }
 @String{Macmillan = "Macmillan" }
 @String{MathWorks = "The Math Works Inc." }
 @String{McGrawHill = "McGraw-Hill" }
 @String{NatBurStd = "National Bureau of Standards" }
 @String{NorthHolland = "North-Holland" }
 @String{OxfordPress = "Oxford University Press" }  %address Oxford or London?
 @String{PergamonPress = "Pergamon Press" }
 @String{PlenumPress = "Plenum Press" }
 @String{PrenticeHall = "Prentice-Hall" }
 @String{SIAMPub = "{SIAM} Publications" }
 @String{Springer = "Springer-Verlag" }
 @String{TexasPress = "University of Texas Press" }
 @String{VanNostrand = "Van Nostrand" }
 @String{WHFreeman = "W. H. Freeman and Co." }

%Entries

@ARTICLE{herlihy:methodology,
    author = {Herlihy, Maurice},
    title = {A Methodology for Implementing Highly Concurrent Data Objects},
    journal = {ACM Trans. Program. Lang. Syst.},
    volume = {15},
    number = {5},
    pages = {745-770},
    month = {November},
    year = {1993},
    doi = {10.1145/161468.161469},
}

@inproceedings{Nik19,
author = {Ruslan Nikolaev},
title = {A Scalable, Portable, and Memory-Efficient Lock-Free {FIFO} Queue},
booktitle = {Proc.\ 33rd International Symposium on Distributed Computing},
series = {LIPIcs},
volume = 146,
year = 2019,
  pages =	{28:1--28:16},
    doi          = {10.4230/LIPIcs.DISC.2019.28},
}

@inproceedings{10.1145/3490148.3538572,
	title        = {{wCQ}: A Fast Wait-Free Queue with Bounded Memory Usage},
	author       = {Nikolaev, Ruslan and Ravindran, Binoy},
	year         = 2022,
	booktitle    = {
		Proc.\ 34th ACM Symposium on Parallelism in Algorithms and
		Architectures
	},
	location     = {Philadelphia, PA, USA},
	pages        = {307--319},
	doi          = {10.1145/3490148.3538572},
	isbn         = 9781450391467,
	url          = {https://doi.org/10.1145/3490148.3538572},
	abstract     = {
		The concurrency literature presents a number of approaches for building
		non-blocking, FIFO, multiple-producer and multiple-consumer (MPMC) queues.
		However, only a fraction of them have high performance. In addition, many
		queue designs, such as LCRQ, trade memory usage for better performance. The
		recently proposed SCQ design achieves both memory efficiency as well as
		excellent performance. Unfortunately, both LCRQ and SCQ are only lock-free.
		On the other hand, existing wait-free queues are either not very performant
		or suffer from potentially unbounded memory usage. Strictly described, the
		latter queues, such as Yang &amp; Mellor-Crummey's (YMC) queue, forfeit
		wait-freedom as they are blocking when memory is exhausted. We present a
		wait-free queue, called wCQ. wCQ is based on SCQ and uses its own variation
		of fast-path-slow-path methodology to attain wait-freedom and bound memory
		usage. Our experimental studies on x86 and PowerPC architectures validate
		wCQ's great performance and memory efficiency. They also show that wCQ's
		performance is often on par with the best known concurrent queue designs.
	},
	numpages     = 13,
	keywords     = {ring buffer, fifo queue, wait-free}
}

@article{10.1145/2370036.2145835,
	title        = {A Methodology for Creating Fast Wait-Free Data Structures},
	author       = {Kogan, Alex and Petrank, Erez},
	year         = 2012,
	journal      = {ACM SIGPLAN Not.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 47,
	number       = 8,
	pages        = {141--150},
	doi          = {10.1145/2370036.2145835},
	issn         = {0362-1340},
	url          = {https://doi.org/10.1145/2370036.2145835},
	issue_date   = {August 2012},
	abstract     = {
		Lock-freedom is a progress guarantee that ensures overall program progress.
		Wait-freedom is a stronger progress guarantee that ensures the progress of
		each thread in the program. While many practical lock-free algorithms exist,
		wait-free algorithms are typically inefficient and hardly used in practice.
		In this paper, we propose a methodology called fast-path-slow-path for
		creating efficient wait-free algorithms. The idea is to execute the efficient
		lock-free version most of the time and revert to the wait-free version only
		when things go wrong. The generality and effectiveness of this methodology is
		demonstrated by two examples. In this paper, we apply this idea to a recent
		construction of a wait-free queue, bringing the wait-free implementation to
		perform in practice as efficient as the lock-free implementation. In another
		work, the fast-path-slow-path methodology has been used for (dramatically)
		improving the performance of a wait-free linked-list.
	},
	numpages     = 10,
	keywords     = {
		concurrent data structures, wait-free queues, non-blocking synchronization,
		lock-free algorithms
	}
}

@inproceedings{DBLP:conf/stoc/AfekDT95,
	title        = {Wait-free made fast},
	author       = {Yehuda Afek and Dalia Dauber and Dan Touitou},
	year         = 1995,
	booktitle    = {
		Proc.\ 27th {ACM} Symposium on Theory of
		Computing
	},
	pages        = {538--547},
	doi          = {10.1145/225058.225271},
	url          = {https://doi.org/10.1145/225058.225271},
	timestamp    = {Tue, 06 Nov 2018 11:07:04 +0100},
	biburl       = {https://dblp.org/rec/conf/stoc/AfekDT95.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/afp/Okasaki96,
	title        = {Functional Data Structures},
	author       = {Chris Okasaki},
	year         = 1996,
	booktitle    = {Advanced Functional Programming, Second International School},
	publisher    = {Springer},
	series       = {LNCS},
	volume       = 1129,
	pages        = {131--158},
	doi          = {10.1007/3-540-61628-4\_5},
	url          = {https://doi.org/10.1007/3-540-61628-4\_5},
	timestamp    = {Tue, 14 May 2019 10:00:44 +0200},
	biburl       = {https://dblp.org/rec/conf/afp/Okasaki96.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/opodis/AttiyaF17,
	title        = {Lower Bounds on the Amortized Time Complexity of Shared Objects},
	author       = {Hagit Attiya and Arie Fouren},
	year         = 2017,
	booktitle    = {21st International Conference on Principles of Distributed Systems},
	series       = {LIPIcs},
	volume       = 95,
	pages        = {16:1--16:18},
	doi          = {10.4230/LIPIcs.OPODIS.2017.16},
	url          = {https://doi.org/10.4230/LIPIcs.OPODIS.2017.16},
	timestamp    = {Tue, 11 Feb 2020 15:52:14 +0100},
	biburl       = {https://dblp.org/rec/conf/opodis/AttiyaF17.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/wdag/David04,
	title        = {A Single-Enqueuer Wait-Free Queue Implementation},
	author       = {Matei David},
	year         = 2004,
	booktitle    = {Proc.\ 18th International Conference on Distributed Computing},
	publisher    = {Springer},
	series       = {LNCS},
	volume       = 3274,
	pages        = {132--143},
	doi          = {10.1007/978-3-540-30186-8\_10},
	url          = {https://doi.org/10.1007/978-3-540-30186-8\_10},
	timestamp    = {Tue, 14 May 2019 10:00:54 +0200},
	biburl       = {https://dblp.org/rec/conf/wdag/David04.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{HW90,
	title        = {Linearizability: A Correctness Condition for Concurrent Objects},
	author       = {Herlihy, Maurice P. and Wing, Jeannette M.},
	year         = 1990,
	journal      = {ACM Trans. Program. Lang. Syst.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 12,
	number       = 3,
	pages        = {463–492},
	doi          = {10.1145/78969.78972},
	issn         = {0164-0925},
	url          = {https://doi.org/10.1145/78969.78972},
	issue_date   = {July 1990},
	abstract     = {
		A concurrent object is a data object shared by concurrent processes.
		Linearizability is a correctness condition for concurrent objects that
		exploits the semantics of abstract data types. It permits a high degree of
		concurrency, yet it permits programmers to specify and reason about
		concurrent objects using known techniques from the sequential domain.
		Linearizability provides the illusion that each operation applied by
		concurrent processes takes effect instantaneously at some point between its
		invocation and its response, implying that the meaning of a concurrent
		object's operations can be given by pre- and post-conditions. This paper
		defines linearizability, compares it to other correctness conditions,
		presents and demonstrates a method for proving the correctness of
		implementations, and shows how to reason about concurrent objects, given they
		are linearizable.
	},
	numpages     = 30
}

@inproceedings{DBLP:conf/wdag/JayantiS21,
	title        = {Fast Arrays: Atomic Arrays with Constant Time Initialization},
	author       = {Siddhartha Jayanti and Julian Shun},
	year         = 2021,
	booktitle    = {Proc.\ 35th International Symposium on Distributed Computing},
	series       = {LIPIcs},
	volume       = 209,
	pages        = {25:1--25:19},
	doi          = {10.4230/LIPIcs.DISC.2021.25},
	url          = {https://doi.org/10.4230/LIPIcs.DISC.2021.25},
	timestamp    = {Wed, 03 Nov 2021 08:28:41 +0100},
	biburl       = {https://dblp.org/rec/conf/wdag/JayantiS21.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/spaa/MilmanKLLP18-old-use-journal-version-instead,
	title        = {{BQ:} {A} Lock-Free Queue with Batching},
	author       = {
		Gal Milman and Alex Kogan and Yossi Lev and Victor Luchangco and Erez Petrank
	},
	year         = 2018,
	booktitle    = {
		Proc.\ 30th Symposium on Parallelism in Algorithms and
		Architectures
	},
	pages        = {99--109},
	doi          = {10.1145/3210377.3210388},
	url          = {https://doi.org/10.1145/3210377.3210388},
	timestamp    = {Wed, 21 Nov 2018 12:44:27 +0100},
	biburl       = {https://dblp.org/rec/conf/spaa/MilmanKLLP18.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{MKLLP22,
author = {Milman-Sela, Gal and Kogan, Alex and Lev, Yossi and Luchangco, Victor and Petrank, Erez},
title = {{BQ}: A Lock-Free Queue with Batching},
year = {2022},
volume = {9},
number = {1},
url = {https://doi.org/10.1145/3512757},
doi = {10.1145/3512757},
abstract = {Concurrent data structures provide fundamental building blocks for concurrent programming. Standard concurrent data structures may be extended by allowing a sequence of operations to be submitted as a batch for later execution. A sequence of such operations can then be executed more efficiently than the standard execution of one operation at a time. In this article, we develop a novel algorithmic extension to the prevalent FIFO queue data structure that exploits such batching scenarios. An implementation in C++ on a multicore demonstrates significant performance improvement of more than an order of magnitude (depending on the batch lengths and the number of threads) compared to previous queue implementations.},
journal = {ACM Trans. Parallel Comput.},
month = mar,
articleno = {5},
numpages = {49},
pages = {5:1--5:49},
keywords = {concurrent data structures, Concurrent algorithms, linearizability, lock-freedom, FIFO queue}
}


@inproceedings{DBLP:conf/podc/ChandraJT98,
	title        = {A Polylog Time Wait-Free Construction for Closed Objects},
	author       = {Tushar Deepak Chandra and Prasad Jayanti and King Tan},
	year         = 1998,
	booktitle    = {
		Proc.\ 17th {ACM} Symposium on Principles of
		Distributed Computing
	},
	pages        = {287--296},
	doi          = {10.1145/277697.277753},
	url          = {https://doi.org/10.1145/277697.277753},
	timestamp    = {Tue, 06 Nov 2018 11:07:19 +0100},
	biburl       = {https://dblp.org/rec/conf/podc/ChandraJT98.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/spaa/TsigasZ01,
	title        = {
		A simple, fast and scalable non-blocking concurrent {FIFO} queue for shared
		memory multiprocessor systems
	},
	author       = {Philippas Tsigas and Yi Zhang},
	year         = 2001,
	booktitle    = {
		Proc.\ 13th {ACM} Symposium on Parallel Algorithms
		and Architectures
	},
	pages        = {134--143},
	doi          = {10.1145/378580.378611},
	url          = {https://doi.org/10.1145/378580.378611},
	timestamp    = {Wed, 21 Nov 2018 12:27:44 +0100},
	biburl       = {https://dblp.org/rec/conf/spaa/TsigasZ01.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/podc/Jayanti98a,
	title        = {
		A Time Complexity Lower Bound for Randomized Implementations of Some Shared
		Objects
	},
	author       = {Prasad Jayanti},
	year         = 1998,
	booktitle    = {
		Proc.\ 17th {ACM} Symposium on Principles of
		Distributed Computing
	},
	pages        = {201--210},
	doi          = {10.1145/277697.277735},
	url          = {https://doi.org/10.1145/277697.277735},
	timestamp    = {Tue, 06 Nov 2018 11:07:19 +0100},
	biburl       = {https://dblp.org/rec/conf/podc/Jayanti98a.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/ppopp/YangM16,
	title        = {A wait-free queue as fast as fetch-and-add},
	author       = {Chaoran Yang and John M. Mellor{-}Crummey},
	year         = 2016,
	booktitle    = {
		Proc.\ 21st {ACM} {SIGPLAN} Symposium on Principles and Practice
		of Parallel Programming
	},
	pages        = {16:1--16:13},
	doi          = {10.1145/2851141.2851168},
	url          = {https://doi.org/10.1145/2851141.2851168},
	timestamp    = {Sun, 12 Jun 2022 19:46:08 +0200},
	biburl       = {https://dblp.org/rec/conf/ppopp/YangM16.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/podc/BashariW21,
	title        = {An Efficient Adaptive Partial Snapshot Implementation},
	author       = {Benyamin Bashari and Philipp Woelfel},
	year         = 2021,
	booktitle    = {Proc.\ {ACM} Symposium on Principles of Distributed Computing},
	pages        = {545--555},
	doi          = {10.1145/3465084.3467939},
	url          = {https://doi.org/10.1145/3465084.3467939},
	timestamp    = {Mon, 26 Jul 2021 09:21:43 +0200},
	biburl       = {https://dblp.org/rec/conf/podc/BashariW21.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{7073592,
	title        = {An Efficient Wait-Free Vector},
	author       = {Feldman, Steven and Valera-Leon, Carlos and Dechev, Damian},
	year         = 2016,
	journal      = {IEEE Transactions on Parallel and Distributed Systems},
	volume       = 27,
	number       = 3,
	pages        = {654--667},
	doi          = {10.1109/TPDS.2015.2417887}
}

@inproceedings{10.1007/978-3-642-41527-2_20,
	title        = {An Optimal Implementation of Fetch-and-Increment},
	author       = {Ellen, Faith and Woelfel, Philipp},
	year         = 2013,
	booktitle    = {Proc.\ 27th International Symposium on Distributed Computing},
	pages        = {284--298},
	doi          = {10.1007/978-3-642-41527-2_20},
	isbn         = 9783642415265,
	series = {LNCS},
	volume = {8205},
	publisher = {Springer},
	url          = {https://doi.org/10.1007/978-3-642-41527-2_20},
	abstract     = {
		We present a new wait-free implementation of a Fetch&Inc object shared by n
		processes from read-write registers and load-linked/store-conditional LL/SC
		objects. The step complexity of each FI operation is Ologn, which is optimal.
		Our implementation uses O max {m,n} objects, each of which stores Ologm bits,
		where m is the number of FI operations that are performed. For large m, the
		number of objects can be reduced to On 2. Similar implementations of other
		objects, such as Fetch&Inc and Swap, are also obtained.Our implementation
		uses a new object, called an Aggregator. It supports an operation which, if
		successful, puts a value into its in-buffer that can depend on the value that
		is currently there, an operation that copies the value in its in-buffer to
		its out-buffer, provided its out-buffer is empty, and an operation that
		empties its out-buffer. We show how to implement an Aggregator from a small
		constant number of LL/SC objects so that all three operations have constant
		step complexity.
	},
	numpages     = 15
}

@article{DBLP:journals/dc/Ladan-MozesS08,
	title        = {An optimistic approach to lock-free {FIFO} queues},
	author       = {Edya Ladan{-}Mozes and Nir Shavit},
	year         = 2008,
	journal      = {Distributed Computing},
	volume       = 20,
	number       = 5,
	pages        = {323--341},
	doi          = {10.1007/s00446-007-0050-0},
	url          = {https://doi.org/10.1007/s00446-007-0050-0},
	timestamp    = {Fri, 13 Mar 2020 14:37:26 +0100},
	biburl       = {https://dblp.org/rec/journals/dc/Ladan-MozesS08.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/opodis/GidenstamST10,
	title        = {
		Cache-Aware Lock-Free Queues for Multiple Producers/Consumers and Weak Memory
		Consistency
	},
	author       = {Anders Gidenstam and H{\aa}kan Sundell and Philippas Tsigas},
	year         = 2010,
	booktitle    = {Proc.\ 14th International Conference on Principles of Distributed Systems},
	series       = {LNCS},
	volume       = 6490,
	pages        = {302--317},
	publisher = {Springer},
	doi          = {10.1007/978-3-642-17653-1\_23},
	url          = {https://doi.org/10.1007/978-3-642-17653-1\_23},
	timestamp    = {Tue, 05 Nov 2019 12:22:56 +0100},
	biburl       = {https://dblp.org/rec/conf/opodis/GidenstamST10.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/ppopp/MorrisonA13,
	title        = {Fast concurrent queues for x86 processors},
	author       = {Adam Morrison and Yehuda Afek},
	year         = 2013,
	booktitle    = {
		Proc.\ {ACM} {SIGPLAN} Symposium on Principles and Practice of Parallel Programming
	},
	pages        = {103--112},
	doi          = {10.1145/2442516.2442527},
	url          = {https://doi.org/10.1145/2442516.2442527},
	timestamp    = {Thu, 24 Jun 2021 16:19:30 +0200},
	biburl       = {https://dblp.org/rec/conf/ppopp/MorrisonA13.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/spaa/HendlerIST10,
	title        = {Flat combining and the synchronization-parallelism tradeoff},
	author       = {Danny Hendler and Itai Incze and Nir Shavit and Moran Tzafrir},
	year         = 2010,
	booktitle    = {
		Proc.\ 22nd {ACM} Symposium on Parallelism in Algorithms
		and Architectures
	},
	pages        = {355--364},
	doi          = {10.1145/1810479.1810540},
	url          = {https://doi.org/10.1145/1810479.1810540},
	timestamp    = {Wed, 21 Nov 2018 11:15:55 +0100},
	biburl       = {https://dblp.org/rec/conf/spaa/HendlerIST10.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/iceccs/ColvinG05,
	title        = {Formal Verification of an Array-Based Nonblocking Queue},
	author       = {Robert Colvin and Lindsay Groves},
	year         = 2005,
	booktitle    = {10th International Conference on Engineering of Complex Computer Systems},
	pages        = {507--516},
    publisher = {IEEE},
	doi          = {10.1109/ICECCS.2005.49},
	url          = {https://doi.org/10.1109/ICECCS.2005.49},
	timestamp    = {Wed, 16 Oct 2019 14:14:51 +0200},
	biburl       = {https://dblp.org/rec/conf/iceccs/ColvinG05.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/stoc/GolabHW11,
	title        = {
		Linearizable implementations do not suffice for randomized distributed
		computation
	},
	author       = {Wojciech M. Golab and Lisa Higham and Philipp Woelfel},
	year         = 2011,
	booktitle    = {Proc.\ 43rd {ACM} Symposium on Theory of Computing},
	pages        = {373--382},
	doi          = {10.1145/1993636.1993687},
	url          = {https://doi.org/10.1145/1993636.1993687},
	timestamp    = {Tue, 06 Nov 2018 11:07:04 +0100},
	biburl       = {https://dblp.org/rec/conf/stoc/GolabHW11.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/fsttcs/JayantiP05,
	title        = {
		Logarithmic-Time Single Deleter, Multiple Inserter Wait-Free Queues and
		Stacks
	},
	author       = {Prasad Jayanti and Srdjan Petrovic},
	year         = 2005,
	booktitle    = {Foundations of Software Technology and Theoretical Computer Science},
	publisher    = {Springer},
	series       = {LNCS},
	volume       = 3821,
	pages        = {408--419},
	doi          = {10.1007/11590156\_33},
	url          = {https://doi.org/10.1007/11590156\_33},
	timestamp    = {Tue, 14 May 2019 10:00:51 +0200},
	biburl       = {https://dblp.org/rec/conf/fsttcs/JayantiP05.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/icdcn/Shafiei09,
	title        = {Non-blocking Array-Based Algorithms for Stacks and Queues},
	author       = {Niloufar Shafiei},
	year         = 2009,
	booktitle    = {Proc.\ 10th International Conference on Distributed Computing and Networking},
	publisher    = {Springer},
	series       = {LNCS},
	volume       = 5408,
	pages        = {55--66},
	doi          = {10.1007/978-3-540-92295-7\_10},
	url          = {https://doi.org/10.1007/978-3-540-92295-7\_10},
	timestamp    = {Tue, 14 May 2019 10:00:42 +0200},
	biburl       = {https://dblp.org/rec/conf/icdcn/Shafiei09.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/podc/MichaelS96,
	title        = {
		Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue
		Algorithms
	},
	author       = {Maged M. Michael and Michael L. Scott},
	year         = 1996,
	booktitle    = {
		Proceedings of the Fifteenth Annual {ACM} Symposium on Principles of
		Distributed Computing
	},
	publisher    = {{ACM}},
	pages        = {267--275},
	doi          = {10.1145/248052.248106},
	url          = {https://doi.org/10.1145/248052.248106},
	timestamp    = {Wed, 14 Nov 2018 10:51:56 +0100},
	biburl       = {https://dblp.org/rec/conf/podc/MichaelS96.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{MS98,
title = {Nonblocking Algorithms and Preemption-Safe Locking on Multiprogrammed Shared Memory Multiprocessors},
journal = {Journal of Parallel and Distributed Computing},
volume = {51},
number = {1},
pages = {1--26},
year = {1998},
issn = {0743-7315},
doi = {https://doi.org/10.1006/jpdc.1998.1446},
url = {https://www.sciencedirect.com/science/article/pii/S0743731598914460},
author = {Maged M. Michael and Michael L. Scott},
keywords = {nonblocking, lock-free, mutual exclusion, locks, multiprogramming, concurrent queues, concurrent stacks, concurrent heaps, concurrent counters, concurrent date structures, , , .},
abstract = {Most multiprocessors are multiprogrammed to achieve acceptable response time and to increase their utilization. Unfortunately, inopportune preemption may significantly degrade the performance of synchronized parallel applications. To address this problem, researchers have developed two principal strategies for a concurrent, atomic update of shared data structures: (1)preemption-safe lockingand (2)nonblocking(lock-free)algorithms. Preemption-safe locking requires kernel support. Nonblocking algorithms generally require a universal atomic primitive such ascompare-and-swaporload-linked/store-conditionaland are widely regarded as inefficient. We evaluate the performance of preemption-safe lock-based and nonblocking implementations of important data structures—queues, stacks, heaps, and counters—including nonblocking and lock-based queue algorithms of our own, in microbenchmarks and real applications on a 12-processor SGI Challenge multiprocessor. Our results indicate that our nonblocking queue consistently outperforms the best known alternatives and that data-structure-specific nonblocking algorithms, which exist for queues, stacks, and counters, can work extremely well. Not only do they outperform preemption-safe lock-based algorithms on multiprogrammed machines, they also outperform ordinary locks on dedicated machines. At the same time, since general-purpose nonblocking techniques do not yet appear to be practical, preemption-safe locks remain the preferred alternative for complex data structures: they outperform conventional locks by significant margins on multiprogrammed systems.}
}

@inproceedings{DBLP:conf/opodis/HoffmanSS07,
	title        = {The Baskets Queue},
	author       = {Moshe Hoffman and Ori Shalev and Nir Shavit},
	year         = 2007,
	booktitle    = {Proc.\ 11th International Conference on Principles of Distributed Systems},
	series       = {LNCS},
	volume       = 4878,
	pages        = {401--414},
	publisher = {Springer},
	doi          = {10.1007/978-3-540-77096-1\_29},
	url          = {https://doi.org/10.1007/978-3-540-77096-1\_29},
	timestamp    = {Tue, 14 May 2019 10:00:52 +0200},
	biburl       = {https://dblp.org/rec/conf/opodis/HoffmanSS07.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/podc/KoganH14,
	title        = {The future(s) of shared data structures},
	author       = {Alex Kogan and Maurice Herlihy},
	year         = 2014,
	booktitle    = {Proc.\ {ACM} Symposium on Principles of Distributed Computing},
	pages        = {30--39},
	doi          = {10.1145/2611462.2611496},
	url          = {https://doi.org/10.1145/2611462.2611496},
	timestamp    = {Tue, 06 Nov 2018 11:07:19 +0100},
	biburl       = {https://dblp.org/rec/conf/podc/KoganH14.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/spaa/MoirNSS05,
	title        = {Using elimination to implement scalable and lock-free {FIFO} queues},
	author       = {Mark Moir and Daniel Nussbaum and Ori Shalev and Nir Shavit},
	year         = 2005,
	booktitle    = {
		Proc.\ 17th  {ACM} Symposium on Parallelism in Algorithms
		and Architectures
	},
	pages        = {253--262},
	doi          = {10.1145/1073970.1074013},
	url          = {https://doi.org/10.1145/1073970.1074013},
	timestamp    = {Wed, 21 Nov 2018 11:12:26 +0100},
	biburl       = {https://dblp.org/rec/conf/spaa/MoirNSS05.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{DBLP:conf/ppopp/KoganP11,
	title        = {Wait-free queues with multiple enqueuers and dequeuers},
	author       = {Alex Kogan and Erez Petrank},
	year         = 2011,
	booktitle    = {
		Proc.\ 16th {ACM} {SIGPLAN} Symposium on Principles and Practice
		of Parallel Programming
	},
	pages        = {223--234},
	doi          = {10.1145/1941553.1941585},
	url          = {https://doi.org/10.1145/1941553.1941585},
	timestamp    = {Wed, 14 Nov 2018 10:55:57 +0100},
	biburl       = {https://dblp.org/rec/conf/ppopp/KoganP11.bib},
	bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@article{10.1145/114005.102808,
	title        = {Wait-Free Synchronization},
	author       = {Herlihy, Maurice},
	year         = 1991,
	journal      = {ACM Trans. Program. Lang. Syst.},
	publisher    = {Association for Computing Machinery},
	address      = {New York, NY, USA},
	volume       = 13,
	number       = 1,
	pages        = {124--149},
	doi          = {10.1145/114005.102808},
	issn         = {0164-0925},
	url          = {https://doi.org/10.1145/114005.102808},
	abstract     = {
		A wait-free implementation of a concurrent data object is one that guarantees
		that any process can complete any operation in a finite number of steps,
		regardless of the execution speeds of the other processes. The problem of
		constructing a wait-free implementation of one data object from another lies
		at the heart of much recent work in concurrent algorithms, concurrent data
		structures, and multiprocessor architectures. First, we introduce a simple
		and general technique, based on reduction to a concensus protocol, for
		proving statements of the form, “there is no wait-free implementation of X by
		Y.” We derive a hierarchy of objects such that no object at one level has a
		wait-free implementation in terms of objects at lower levels. In particular,
		we show that atomic read/write registers, which have been the focus of much
		recent attention, are at the bottom of the hierarchy: thay cannot be used to
		construct wait-free implementations of many simple and familiar data types.
		Moreover, classical synchronization primitives such astest&set and fetch&add,
		while more powerful than read and write, are also computationally weak, as
		are the standard message-passing primitives. Second, nevertheless, we show
		that there do exist simple universal objects from which one can construct a
		wait-free implementation of any sequential object.
	},
	numpages     = 26,
	keywords     = {wait-free synchronization, linearization}
}

@misc{Rup16,
author = {Eric Ruppert},
title = {Analysing the average time complexity of lock-free data structures},
year = 2016,
howpublished = {Presented at BIRS Workshop on Complexity and Analysis of Distributed Algorithms},
note = {Available from \url{http://www.birs.ca/videos/2016}.}
}

 @inproceedings{FR04,
  author    = {Mikhail Fomitchev and Eric Ruppert},
  title     = {Lock-free linked lists and skip lists},
  booktitle = {Proc.\ 23rd ACM Symposium on Principles of Distributed Computing},
  year      = {2004},
    doi          = {10.1145/1011767.1011776},
  pages     = {50--59},
}

@inproceedings{EFHR14,
author = {Faith Ellen and Panagiota Fatourou and Joanna Helga and Eric Ruppert},
title = {The Amortized Complexity of Non-blocking Binary Search Trees},
booktitle = {Proc.\ 33rd ACM Symposium on Principles of Distributed Computing},
year = 2014,
pages = {332--340},
  doi          = {10.1007/978-3-642-25873-2\_15},
}

@inproceedings{BBFRSW21,
author    = {Naama Ben{-}David and
               Guy E. Blelloch and
               Panagiota Fatourou and
               Eric Ruppert and
               Yihan Sun and
               Yuanhao Wei},
  title     = {Space and Time Bounded Multiversion Garbage Collection},
  booktitle = {Proc.\ 35th International Symposium on Distributed Computing},
  series    = {LIPIcs},
  volume    = {209},
  pages     = {12:1--12:20},
  year      = {2021},
  url       = {https://doi.org/10.4230/LIPIcs.DISC.2021.12},
  doi       = {10.4230/LIPIcs.DISC.2021.12},
  }

@inproceedings{Sha15,
author = {Niloufar Shafiei},
title = {Non-blocking doubly-linked lists with good amortized complexity},
booktitle = {Proc.\ 19th International Conference on Principles of Distributed Systems},
year = 2015,
pages = {35:1--35:17},
series = {{LIPIcs}},
volume = 46,
  doi          = {10.4230/LIPIcs.OPODIS.2015.35},
}

@techreport{Tre86,
title = {Systems programming: Coping with parallelism},
author = {R.K. Treiber},
year = 1986,
number = {RJ 5118},
institution = {IBM Almaden Research Center}
}

@inproceedings{KW18,
author = {Pankaj Khanchandani and Roger Wattenhofer},
title = {On the Importance of Synchronization Primitives with Low Consensus Numbers},
  booktitle = {Proc.~19th International Conference on Distributed Computing
               and Networking},
  pages     = {18:1--18:10},
  year      = {2018},
  url       = {https://doi.org/10.1145/3154273.3154306},
  doi       = {10.1145/3154273.3154306},
}

@techreport{MP91,
author = {Henry Massalin and Carlton Pu},
title = {A Lock-Free Multiprocessor {OS} Kernel},
institution = {Department of Computer Science, Columbia University},
number = {CUCS-005-91},
year = 1991}

@book{Tar83,
author = {Robert Endre Tarjan},
title = {Data Structures and Network Algorithms},
year = 1983,
publisher = {SIAM},
address = {Philadelphia, USA},
comment = {see p.53 for split on RBTs}
}

@inproceedings{10.1145/3018743.3019022,
author = {Ramalhete, Pedro and Correia, Andreia},
title = {POSTER: A Wait-Free Queue with Wait-Free Memory Reclamation},
year = {2017},
isbn = {9781450344937},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3018743.3019022},
doi = {10.1145/3018743.3019022},
abstract = {Queues are a widely deployed data structure. They are used extensively in many multi threaded applications, or as a communication mechanism between threads or processes. We propose a new linearizable multi-producer-multi-consumer queue we named Turn queue, with wait-free progress bounded by the number of threads, and with wait-free bounded memory reclamation. Its main characteristics are: a simple algorithm that does no memory allocation apart from creating the node that is placed in the queue, a new wait-free consensus algorithm using only the atomic instruction compare-and-swap (CAS), and is easy to plugin with other algorithms for either enqueue or dequeue methods.},
booktitle = {Proceedings of the 22nd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
pages = {453?454},
numpages = {2},
keywords = {non-blocking queue, low latency, wait-free},
location = {Austin, Texas, USA},
series = {PPoPP '17}
}

  

@article{RC17,
author = {Ramalhete, Pedro and Correia, Andreia},
title = {Poster: A Wait-Free Queue with Wait-Free Memory Reclamation},
year = {2017},
volume = {52},
number = {8},
issn = {0362-1340},
url = {https://doi.org/10.1145/3155284.3019022},
doi = {10.1145/3155284.3019022},
abstract = {Queues are a widely deployed data structure. They are used extensively in many multi threaded applications, or as a communication mechanism between threads or processes. We propose a new linearizable multi-producer-multi-consumer queue we named Turn queue, with wait-free progress bounded by the number of threads, and with wait-free bounded memory reclamation. Its main characteristics are: a simple algorithm that does no memory allocation apart from creating the node that is placed in the queue, a new wait-free consensus algorithm using only the atomic instruction compare-and-swap (CAS), and is easy to plugin with other algorithms for either enqueue or dequeue methods.},
journal = {ACM SIGPLAN Not.},
month = jan,
pages = {453--454},
keywords = {low latency, wait-free, non-blocking queue}
}

@misc{DPDK,
author = {{DPDK Project}},
title = {Data Plane Development Kit},
note = {\url{www.dpdk.org}},
}

@article{FK14,
author    = {Panagiota Fatourou and
               Nikolaos D. Kallimanis},
  title     = {Highly-Efficient Wait-Free Synchronization},
  journal   = {Theory of Computing Systems},
  volume    = {55},
  number    = {3},
  pages     = {475--520},
  year      = {2014},
  url       = {https://doi.org/10.1007/s00224-013-9491-y},
  doi       = {10.1007/s00224-013-9491-y},
  timestamp = {Sun, 28 May 2017 13:18:24 +0200},
  biburl    = {https://dblp.org/rec/journals/mst/FatourouK14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{ERW12,
author = {Faith Ellen and Vijaya Ramachandran and Philipp Woelfel},
title = {Efficient Fetch-and-Increment},
booktitle = {Proc.\ International Symposium on Distributed Computing},
pages = {16--30},
year = 2012,
series = {LNCS},
  doi          = {10.1007/978-3-642-33651-5\_2},
publisher = {Springer},
volume = 7611,
}

@article{BY76,
title = {An almost optimal algorithm for unbounded searching},
journal = {Information Processing Letters},
volume = {5},
number = {3},
pages = {82--87},
year = {1976},
doi = {https://doi.org/10.1016/0020-0190(76)90071-5},
url = {https://www.sciencedirect.com/science/article/pii/0020019076900715},
author = {Jon Louis Bentley and Andrew Chi-Chih Yao},
keywords = {Ordered table searching, optimal algorithms, analysis of algorithms, representation of integers}
}

@article{Ko20,
  author    = {Jeremy Ko},
  title     = {The amortized analysis of a non-blocking chromatic tree},
  journal   = {Theoretical Computer Science},
  volume    = {840},
  pages     = {59--121},
  month = nov,
  year      = {2020},
  url       = {https://doi.org/10.1016/j.tcs.2020.07.007},
  doi       = {10.1016/j.tcs.2020.07.007},
}

@article{DSST89,
author = {James R. Driscoll and Neil Sarnak and Daniel D. Sleator and Robert E. Tarjan},
title = {Making Data Structures Persistent},
journal = {Journal of Computer and System Sciences},
volume = 38,
number = 1,
month = feb,
year = 1989,
  doi          = {10.1016/0022-0000(89)90034-2},
pages = {86--124}
}

@inproceedings{RK23,
title = {The state-of-the-art {LCRQ} concurrent queue algorithm does {NOT} require {CAS2}},
author = {Raed Romanov and Nikita Koval},
booktitle = {Proc.\ ACM Symposium on Principles and Practice of Parallel Programming},
year = 2023,
pages = {14--26},
  doi          = {10.1145/3572848.3577485},
}

@inproceedings{JKM23,
title = {Efficient Wait-Free Queue Algorithms with Multiple Enqueuers and Multiple Dequeuers},
author = {Colette Johnen and Adnane Khattabi and Alessia Milani},
booktitle = {Proc.\ 26th International Conference on Principles of Distributed Systems},
pages = {4:1--4:19},
month = feb,
year = 2023,
series = {LIPIcs},
volume = 253,
  doi          = {10.4230/LIPIcs.OPODIS.2022.4},
}

@inproceedings{KAE23,
author = {Nikita Koval and Dan Alistarh and Roman Elizarov},
title = {Fast and Scalable Channels in {Kotlin} Coroutines},
year = 2023,
pages = {107--118},
  doi          = {10.1145/3572848.3577481},
booktitle = {Proc. ACM Symposium on Principles and Practice of Parallel Programming},
}

@mastersthesis{Nad22,
author = "Hossein Naderibeni",
title = "A Wait-free Queue with Poly-logarithmic Worst-case Step Complexity",
school = "York University",
address = "Toronto, Canada",
month = nov,
year = 2022,
}

@unpublished{full,
author = {Hossein Naderibeni and Eric Ruppert},
title = {A Wait-free Queue with Polylogarithmic Step Complexity},
year = 2023,
note = {Full version of this paper available from arxiv.org}
}