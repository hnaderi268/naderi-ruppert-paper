% !TEX root =  podc-submission.tex

\subsection{Correctness}
Unfortunately, there are enough changes to the algorithm that a new proof of correctness
is required.  Its structure mirrors the proof of the original algorithm, but requires additional
reasoning to ensure GC does not interfere with other routines.

\begin{observation}\label{RBTinsertions}
When a block is inserted into an RBT $T$, its \fld{index} is one greater than the maximum \fld{index} in $T$.
\end{observation}
\begin{proof}
If line \ref{appendLeafGC} inserts a block into a leaf's RBT, then it was created at 
line \ref{enqNewGC} or \ref{deqNewGC} with \fld{index} $h+1$, where $h$ is the maximum \fld{index}
in the leaf's RBT.  When the new block is inserted, the maximum \fld{index} in the RBT is still $h$,
since only the owner of the leaf modifies the leaf's RBT.

If line \ref{refreshInsertGC} inserts a block  into an internal node's RBT $T$,
it is created by the call to \op{CreateBlock} at line \ref{invokeCreateBlockGC} and 
has \fld{index} $h$, which is set at line \ref{refreshReadMax} to  the maximum \fld{index} in $T$ plus one.
\end{proof}

\begin{observation}\label{lastinroot}
Each entry in \var{last} is the \var{index} of a block that has appeared in the root's RBT.
\end{observation}
\begin{proof}
Only line \ref{setlast1} and \ref{setlast2} in \op{FindResponse} write values into \var{last}.
The value written is either $b$ or $b_e \leq b$.
By the precondition of \op{FindResponse}, $\var{root}.\fld{blocks}[b]$ exists, so the index $b$ has appeared
in the root's RBT.
By \Cref{RBTinsertions}, all values less than $b$ have appeared in the root's RBT too.
\end{proof}

\begin{observation}
\label{edirGC} 
If $B$ is a block in the RBT of an internal node $v$, then for $\var{dir} \in \{\fld{left},\fld{right}\}$,
$B.\edir$ was read from the \fld{index} field of some node in the RBT of $v.\var{dir}$.
\end{observation}
\begin{proof}
The \eleft\ and \eright\ fields are set by reading the \fld{index} field of a node in the appropriate child
on line \ref{createEndLeftGC} and \ref{createEndRightGC}.
\end{proof}

\begin{invariant}\label{nonemptyConsec}
For each RBT $T$, 
$T$ is non-empty and the blocks of $T$ have consecutive \fld{index} fields.
\end{invariant}
\begin{proof}
The claim is true initially, since each RBT initially contains only the empty block with \fld{index} 0.
We show that each time a new RBT is constructed, it preserves the invariant.
When a new RBT is created by inserting an element into an existing RBT, \Cref{RBTinsertions}
implies that the invariant is preserved.

Suppose a new RBT is created by a \op{Split}($T,t$) operation $S$ on at line \ref{split} of a \op{Discard}($v,t$), 
and that the invariant held prior to $S$.
Clearly, $S$ preserves the property that indices are consecutive.  To show that the new tree
is non-empty we first prove that the call to \op{Discard}($v,t$) has a parameter $t$ that is at least as big as a value previously
read from the index field of some block in $v$'s RBT.
If \op{Discard} was called from line \ref{discard}, then $t+1$ was read from an entry of \var{last}, so the claim follows from \Cref{lastinroot}.
If \op{Discard} was called from line \ref{discardrecurse1} or \ref{discardrecurse2}, the claim follows
from \Cref{edirGC}.
Since the invariant held prior to $S$, no split before $S$ emptied $v$'s tree.  Therefore,
some block with index at least $t$ is still in $T$ when $S$ occurs.  That block will be in the new tree created by $S$.
\end{proof}

Since RBTs are always non-empty, calls to \op{MaxBlock} are well-defined.  
Throughout the proof, we use $v.\blocks[b]$ to refer to the block with \fld{index} $b$ that appeared
in $v$'s tree at some time during the execution.
It follows from \Cref{RBTinsertions} and \Cref{nonemptyConsec} that this block is unique, if 
it exists.
We also use this notation in the code to indicate that a search of the RBT should be performed for the block
with \fld{index} $b$.
We describe later what should happen if the block is not found by the search because it has been removed
by a GC phase.
\here{remember to come back to this point}

\begin{corollary}\label{maxNonDecreasing}
The maximum \fld{index} in $v$'s RBT is non-decreasing over time.
\end{corollary}
\begin{proof}
The CAS steps (on line \ref{casGC} and \ref{splitCASGC}) that update $v.\fld{blocks}$ always replace 
a tree $T$ by a tree that is built from $T$ by inserting an element and/or removing the elements with 
the smallest \fld{index} values, without emptying the tree.  Thus, the maximum \fld{index} in the tree cannot decrease.
\end{proof}

We now prove the analogue of Lemma \ref{lem::headProgress}.
\begin{lemma}
 If $b>0$ and a block with index $b$ has been inserted into $v.\fld{blocks}$ then 
 $v.\fld{blocks}[b-1].\fld{end\sub{left}} \leq v.\fld{blocks}[b].\fld{end\sub{left}}$ and 
 $v.\fld{blocks}[b-1].\fld{end\sub{right}} \leq v.\fld{blocks}[b].\fld{end\sub{right}}$.
\end{lemma}
\begin{proof}
The block $B$ with index $b$ was installed into $v$'s RBT by the CAS at line \ref{casGC} or \ref{splitCASGC} 
that changed the tree from $T$ to $T_{new}$.
Before this CAS, the tree $T$ was read from $v.blocks$ at line \ref{readTGC} or \ref{readT2GC}, respectively,
before the \op{RefreshUpdate} on line \ref{RU1} or \ref{RU2} that inserted $B$ to get $T_{new}$.
Since the previous block $B'=v.\fld{blocks}[b-1]$ was already in $T$ (by \Cref{RBTinsertions}),
the \op{CreateBlock}$(v,b-1)$ that created $B'$ terminated before the \op{CreateBlock}$(v,b)$ that created $B$ started.
It follows from \Cref{maxNonDecreasing} that the value that line \ref{createEndLeftGC} of \op{CreateBlock}$(v,b-1)$ stores in $B'.\eleft$ is less than or equal to the value that line \ref{createEndLeftGC} of \op{CreateBlock}$(v,b)$ stores in $B.\eleft$.  Similarly, the values stored in $B'.\eright$ and $B.\eright$ at line \ref{createEndRightGC} satisfy the claim.
\end{proof}

\Cref{lem::subblocksDistinct}, \Cref{lem::noDuplicates}, \Cref{lem::sum}, \Cref{blockNotEmpty} 
hold true for the modified algorithm.  Their proofs are identical to those given in 
Section \ref{sec::basicProperties} since they only depend on \Cref{lem::headProgress} 
and the definition of subblocks given in (\ref{defsubblock}).
The following pair of lemmas are analogous to \Cref{successfulRefresh} for the modified \op{Refresh} routine.
We say that an operation has been \emph{propagated} to node $v$ in configuration $C$ if
some block containing the operation has been in $v.blocks$ at or before $C$.

\begin{lemma}\label{nullRefreshGC}
Suppose $v.\fld{blocks}=T$ at some configuration $C$ and \op{RefreshUpdate}($T,v$) is invoked after $C$ and
returns \nl.  Then, all operations that were propagated to $v$'s
children before $C$ have been propagated to $v$ before $C$.
\end{lemma}
\begin{proof}
Suppose an operation $op$ has been propagated to $v$'s child (without loss of generality, $v.\fld{left}$) before $C$.
Then, for some $i$, a block $B$ with \fld{index} $i$ has been in $v.\fld{left.blocks}$ before $C$.
By Lemma \ref{maxNonDecreasing}, 
the maximum \fld{index} in $v.\fld{left.blocks}$ is at least $i$ at all times during the \op{RefreshUpdate}.
So, the value of $\var{new}.\eleft$ chosen at line \ref{createEndLeftGC} of the \op{RefreshUpdate}'s call
to \op{CreateBlock} is at least $i$.

Let $h$ be the value set at line \ref{refreshReadMax} of the \op{RefreshUpdate}.
The \op{RefreshUpdate} returns \nl\ at line \ref{addOPGC}
because the \op{CreateBlock}$(v,h)$  at line \ref{CBnullGC} returns \nl.
By reasoning identical to the last paragraph of \Cref{successfulRefresh},
it follows from the fact that $\var{num\sub{enq}}+\var{num\sub{deq}}=0$ that
the blocks $v.\fld{left.blocks}[v.\fld{blocks}[h-1].\eleft+1..new.\eleft]$ and
$v.\fld{right.blocks}[v.\fld{blocks}[h-1].\eright+1..new.\eright]$
contain no operations.
Since each block contains at least one operation by \Cref{blockNotEmpty}
these ranges must be empty, so $v.\fld{blocks}[h-1].\eleft \geq \var{new}.\eleft\geq i$.
This implies that the block $B$ containing $op$ is a subblock of some block that has appeared in $v.\fld{blocks}$, so $op$ has been propagated to $v$.
\end{proof}

\begin{lemma}\label{successfulRefreshGC}
If a \op{CAS} at line \ref{casGC} or \ref{splitCASGC} modifies $v.\fld{blocks}$ from $T$ to $T'$,
then all operations that were propagated to $v$'s children before $v.\fld{blocks}$ was set to $T$
have been propagated to $v$ in the configuration after the CAS.
\end{lemma}
\begin{proof}
Suppose an operation $op$ has been propagated to $v$'s child (without loss of generality, $v.\fld{left}$) before $v.\fld{blocks}$ was set to $T$.
Then, for some $i$, a block $B$ with \fld{index} $i$ that contains $op$
has been in $v.\fld{left.blocks}$ before $v.\fld{blocks}$ was set to $T$.
Let $c$ be the \op{CAS} instruction that changes $v.\fld{blocks}$ from $T$ to $T'$.
If line \ref{casGC} performs $c$, then the \op{RefreshUpdate} $R$ at line \ref{RU1} that creates
$T'$ began after $T$ was read from $v.\fld{blocks}$ at line \ref{readTGC}.
Otherwise, line \ref{splitCASGC} performs $c$ and the \op{RefreshUpdate} $R$ at line \ref{RU2},
which is invoked after $T$ was read from $v.\fld{blocks}$ at line \ref{readT2GC},
either returned \nl\ or $T'$.

If the \op{RefreshUpdate} $R$ returned \nl, the lemma follows from \Cref{nullRefreshGC}.
So, assume \op{RefreshUpdate} $R$ returned $T'$.
Then $T'$ contains a newly inserted block created by the call
to \op{CreateBlock} on line \ref{invokeCreateBlockGC}.
Since $R$ was invoked after $T$ was stored in $v.\fld{blocks}$, 
the maximum \fld{index} in $v.\fld{left.blocks}$ is at least $i$ throughout $R$, by \Cref{maxNonDecreasing}.
Thus. the \eleft\ field of the new block added to $T'$ by $R$'s call to \op{CreateBlock} is
set to a value greater than or equal to $i$ at line \ref{createEndLeftGC}.
By the definition of subblocks, it follows that the block $B$ containing $op$ is a subblock of a block
that has been in $v.blocks$, as required.
\end{proof}

This allows us to show that a double \op{Refresh} propagates operations up the tree, 
as in \Cref{lem::doubleRefresh}.

\begin{lemma}\label{lem::doubleRefreshGC}
Consider two consecutive terminating calls $R_1$, $R_2$ to \op{GCRefresh}($v$) by the same process.
All operations propagated to $v$'s children when $R_1$ begins
are propagated to $v$ when $R_2$ terminates.
\end{lemma}
\begin{proof}
\end{proof}






-------

In our design a process attempts to collect the garbage, when it is going to to append a block in the $kp^2$ position in \nf{root.blocks} (see Line \ref{}). Every $p^2$  block appended to the root, one \nf{GarbageCollect} terminates because \nf{root.head} cannot advance until a \nf{GarbageCollect} garbage collect is done (see Lines ).

%\begin{lemma}
%Size of \nf{root.blocks} after \nf{GarbageCollect} is $O(p^2+q)$.
%\end{lemma}
%
%\begin{lemma}
%Total number of the blocks in the tree is $O(p^3+pq)$.
%\end{lemma}

\nf{Enqueue} operation $e$ can be removed from the tree after termination of \nf{Dequeue} $d$ where $Resp(d)=e$. It is safe to remove \nf{Dequeue} $d$ from the tree after the $d$ terminates. We can remove a block after the conditions told are satisfied for all of its \nf{Enqueue}s and \nf{Dequeue}s. A \nf{Dequeue} may go to sleep for a long time and prevent a \nf{block} to be removed (the block it is in or the block its response is in). In that situation other processes can help the \nf{Dequeue} by computing its response and writing it down somewhere. After writing down the response of th \nf{Dequeue} can be removed, since if the process wanted the response it can read from the helped response.

\begin{definition}
A block  is \it{finished} if all of its \nf{Enqueue}s have been computed to be the response of some \nf{Dequeue} and all of its \nf{Dequeues} responses have been computed.  
\end{definition}

\begin{corollary}
If a block is finished, then all of its subblocks are also finished.  
\end{corollary}

\begin{lemma}
It is safe to remove a finished block from the non-leaf nodes.
\end{lemma}

If the $i$th \nf{Enqueue} gets dequeued in a FIFO queue, it means the first $i-1$ \nf{Enqueue} operations have been already dequeued. This gives us the idea that if a block is finished then all the blocks before it are also finished. If an operation in a block goes to sleep for a long time then other processes help the operation so the block gets finished. There are less than $p$ idle operations, we can help them before garbage collection and then remove all the finished blocks safely in an amortized poly-log time.

\begin{lemma}
    If all \nf{Dequeue} operations in the root are helped, then all the blocks before a finished block in the root are also finished.
\end{lemma}

\begin{lemma}
  Blocks before the most recent block that has been dequeued(computed to be dequeue) from are finished. If the most current \nf{Dequeue} returned(computed) \nf{null} then all the blocks before the block containing the \nf{Dequeue} are finished.
\end{lemma}

The idea above leads us to a poly-log data structure that supports throwing away all the blocks with keys smaller than an index. Red-black trees do this for us. \nf{Get(i)}, \nf{Append()} and \nf{Split(i)} are logarithmic in block trees.
We can create a shared red-black tree just creating a new path for the operation and then using \nf{CAS} to change the root of the tree. See [this] for more.

\begin{observation}
PBRT supports poly-log operations ....
\end{observation}

\begin{lemma}
    If we replace the arrays we used to implement \nf{blocks} with red-black trees the amortized complexity of the algorithm would be $PolyLog(p,q)$. And also the algorithm is correct.
\end{lemma}

We can help a \nf{Dequeue} by computing its response and writing it down. If the process in future failed to execute, it can read the helped value written down.

\begin{lemma}
The \nf{response} written is correct.
\end{lemma}

But how can we know which blocks in each node are finished or not? 

\begin{observation}
Every $p^2$ block appended to the root, \nf{FreeMemory} is invoked.  
\end{observation}

To know the last block dequeied from we can implement a shared array among processes which they write the last root block they have dequeued from. 

\begin{lemma}
    $\nf{Max(Last)} - \text{index of the last finished block}$ in the node $n$ is $O(p)$.
\end{lemma}

\begin{lemma}
    After \nf{FreeMemory}, the space taken by each node of the tree is $O(p+q)$.
\end{lemma}

\begin{corollary}
The space taken by each node of the tree is $O(p^2+q)$. The total space in the tree is $PolyLog(p+q)$.
\end{corollary}

\begin{lemma}
  The amortized step per process for the algorithm with garbage collection is $PolyLog(p+q)$.
\end{lemma}

\begin{lemma}
  Algorithm is wait-free and linearizable.
\end{lemma}

\here{Remark on an optimization:  instead of storing \head\ field separate from \fld{blocks}, we could store
the maximum index of the RBT in the root of the RBT.  This would simplify things, but require modifying the proof more extensively.}

