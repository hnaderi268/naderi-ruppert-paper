% !TEX root =  podc-submission.tex

\section{Garbage Collection}

In our algorithm an \nf{Enqueue} or a \nf{Dequeue} remains in the \nf{blocks} array in the tree nodes even after they terminate. This makes the space used by the algorithm factor of the number of operations of invoked on the queue. Here in this section, we want to add a mechanism to free the memory allocated by the operations that are no longer needed and make the overall space used polynomial of $p+q$.

It is a common way to do garbage collection in batches. If we garbage collect the unnecessary blocks in the nodes every $p^2$ block appended to the root, the garbage collection cost is amortized over $p^2$ blocks which is $O(p^3)$ and $\Omega(p^2)$ operations.

In our design a process attempts to collect the garbage, when it is going to to append a block in the $kp^2$ position in \nf{root.blocks} (see Line \ref{}). Every $p^2$  block appended to the root, one \nf{GarbageCollect} terminates because \nf{root.head} cannot advance until a \nf{GarbageCollect} garbage collect is done (see Lines ).

%\begin{lemma}
%Size of \nf{root.blocks} after \nf{GarbageCollect} is $O(p^2+q)$.
%\end{lemma}
%
%\begin{lemma}
%Total number of the blocks in the tree is $O(p^3+pq)$.
%\end{lemma}

\nf{Enqueue} operation $e$ can be removed from the tree after termination of \nf{Dequeue} $d$ where $Resp(d)=e$. It is safe to remove \nf{Dequeue} $d$ from the tree after the $d$ terminates. We can remove a block after the conditions told are satisfied for all of its \nf{Enqueue}s and \nf{Dequeue}s. A \nf{Dequeue} may go to sleep for a long time and prevent a \nf{block} to be removed (the block it is in or the block its response is in). In that situation other processes can help the \nf{Dequeue} by computing its response and writing it down somewhere. After writing down the response of th \nf{Dequeue} can be removed, since if the process wanted the response it can read from the helped response.

\begin{definition}
A block  is \it{finished} if all of its \nf{Enqueue}s have been computed to be the response of some \nf{Dequeue} and all of its \nf{Dequeues} responses have been computed.  
\end{definition}

\begin{corollary}
If a block is finished, then all of its subblocks are also finished.  
\end{corollary}

\begin{lemma}
It is safe to remove a finished block from the non-leaf nodes.
\end{lemma}

If the $i$th \nf{Enqueue} gets dequeued in a FIFO queue, it means the first $i-1$ \nf{Enqueue} operations have been already dequeued. This gives us the idea that if a block is finished then all the blocks before it are also finished. If an operation in a block goes to sleep for a long time then other processes help the operation so the block gets finished. There are less than $p$ idle operations, we can help them before garbage collection and then remove all the finished blocks safely in an amortized poly-log time.

\begin{lemma}
    If all \nf{Dequeue} operations in the root are helped, then all the blocks before a finished block in the root are also finished.
\end{lemma}

\begin{lemma}
  Blocks before the most recent block that has been dequeued(computed to be dequeue) from are finished. If the most current \nf{Dequeue} returned(computed) \nf{null} then all the blocks before the block containing the \nf{Dequeue} are finished.
\end{lemma}

The idea above leads us to a poly-log data structure that supports throwing away all the blocks with keys smaller than an index. Red-black trees do this for us. \nf{Get(i)}, \nf{Append()} and \nf{Split(i)} are logarithmic in block trees.
We can create a shared red-black tree just creating a new path for the operation and then using \nf{CAS} to change the root of the tree. See [this] for more.

\begin{observation}
PBRT supports poly-log operations ....
\end{observation}

\begin{lemma}
    If we replace the arrays we used to implement \nf{blocks} with red-black trees the amortized complexity of the algorithm would be $PolyLog(p,q)$. And also the algorithm is correct.
\end{lemma}

We can help a \nf{Dequeue} by computing its response and writing it down. If the process in future failed to execute, it can read the helped value written down.

\begin{lemma}
The \nf{response} written is correct.
\end{lemma}

But how can we know which blocks in each node are finished or not? 

\begin{observation}
Every $p^2$ block appended to the root, \nf{FreeMemory} is invoked.  
\end{observation}

To know the last block dequeied from we can implement a shared array among processes which they write the last root block they have dequeued from. 

\begin{lemma}
    $\nf{Max(LastDequeuedFrom)} - \text{index of the last finished block}$ in the node $n$ is $O(p)$.
\end{lemma}

\begin{lemma}
    After \nf{FreeMemory}, the space taken by each node of the tree is $O(p+q)$.
\end{lemma}

\begin{corollary}
The space taken by each node of the tree is $O(p^2+q)$. The total space in the tree is $PolyLog(p+q)$.
\end{corollary}

\begin{lemma}
  The amortized step per process for the algorithm with garbage collection is $PolyLog(p+q)$.
\end{lemma}

\begin{lemma}
  Algorithm is wait-free and linearizable.
\end{lemma}





















